---
description: Guidelines for React components and Next.js App Router pages
globs:
  - frontend/src/components/**/*.tsx
  - frontend/src/app/**/*.tsx
  - frontend/src/lib/**/*.ts
  - frontend/src/lib/**/*.tsx
alwaysApply: false
---

# Frontend Component Guidelines

## React 19 Best Practices

Use modern React 19 patterns:
- Server Components by default (in Next.js App Router)
- Add `'use client'` directive only when needed (state, effects, browser APIs)
- Use async Server Components for data fetching
- Leverage React Server Actions for mutations

## Component Architecture

### Keep Components Small and Focused

Extract items from array maps into separate components:

```typescript
// ❌ Bad: Inline complex JSX in map
{items.map(item => (
  <div key={item.id}>
    <h3>{item.title}</h3>
    <p>{item.description}</p>
    <button onClick={() => handleClick(item)}>Action</button>
  </div>
))}

// ✅ Good: Extract to dedicated component
{items.map(item => (
  <ItemCard key={item.id} item={item} onAction={handleClick} />
))}
```

### Extract Pure Functions

Move business logic and data transformations out of components:

```typescript
// ❌ Bad: Logic inside component
function UserProfile({ user }) {
  const fullName = `${user.firstName} ${user.lastName}`.trim();
  const isActive = user.status === 'active' && user.lastSeen > Date.now() - 300000;
  return <div>{fullName} - {isActive ? 'Online' : 'Offline'}</div>;
}

// ✅ Good: Extract to pure functions
// lib/user.utils.ts
export function getUserFullName(user: User): string {
  return `${user.firstName} ${user.lastName}`.trim();
}

export function isUserActive(user: User): boolean {
  return user.status === 'active' && user.lastSeen > Date.now() - 300000;
}

// Component
function UserProfile({ user }) {
  return <div>{getUserFullName(user)} - {isUserActive(user) ? 'Online' : 'Offline'}</div>;
}
```

### Extract Business Logic to Pure Functions or Queries

Keep components thin - move logic to utilities or TanStack Query:

```typescript
// ❌ Bad: Business logic in component
function Dashboard() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    const filtered = rawData.filter(item => item.status === 'active');
    const sorted = filtered.sort((a, b) => b.priority - a.priority);
    const enriched = sorted.map(item => ({
      ...item,
      score: calculateComplexScore(item)
    }));
    setData(enriched);
  }, [rawData]);
  
  return <div>...</div>;
}

// ✅ Good: Extract to pure functions
// lib/dashboard.utils.ts
export function processDashboardData(rawData: RawData[]): ProcessedData[] {
  return rawData
    .filter(item => item.status === 'active')
    .sort((a, b) => b.priority - a.priority)
    .map(item => ({
      ...item,
      score: calculateComplexScore(item)
    }));
}

// Component
function Dashboard() {
  const processedData = processDashboardData(rawData);
  return <div>...</div>;
}
```

## Component Structure

```typescript
// Server Component (default)
export default async function ServerComponent() {
  const data = await fetchData();
  return <div>{data.title}</div>;
}

// Client Component (when needed)
'use client';

import { useState } from 'react';

export function ClientComponent() {
  const [state, setState] = useState();
  return <button onClick={() => setState(...)}>Click</button>;
}
```

## Data Fetching with TanStack Query

**ALWAYS use TanStack Query** for data fetching. Never call HTTP clients directly from client components.

### Use useQuery with Explicit Loading States

Prefer `useQuery` over `useSuspenseQuery` for explicit control over loading/error states.
Use the `LoadingWrapper` component to reduce boilerplate:

```typescript
// lib/chat.query.ts
import { useQuery } from '@tanstack/react-query';
import { apiClient } from './api-client';

export function useChatMessages(chatId: string) {
  return useQuery({
    queryKey: ['chats', chatId, 'messages'],
    queryFn: () => apiClient.get(`/chats/${chatId}/messages`),
  });
}

// Component - using LoadingWrapper
'use client';

import { LoadingWrapper } from '@/components/loading-wrapper';

function ChatMessages({ chatId }: Props) {
  const { data, isPending, error } = useChatMessages(chatId);

  return (
    <LoadingWrapper isPending={isPending} error={error} skeleton={<MessagesSkeleton />}>
      <MessageList messages={data ?? []} />
    </LoadingWrapper>
  );
}

// Alternative - inline for simple cases
function ChatMessages({ chatId }: Props) {
  const { data, isPending } = useChatMessages(chatId);

  if (isPending) return <MessagesSkeleton />;

  return <MessageList messages={data ?? []} />;
}
```

### Prefetch on Server, Pass as Initial Data

```typescript
// app/chat/[id]/page.tsx (Server Component)
import { dehydrate, HydrationBoundary, QueryClient } from '@tanstack/react-query';
import { ChatView } from './chat-view';

export default async function ChatPage({ params }: Props) {
  const queryClient = new QueryClient();
  
  // Prefetch data on server
  await queryClient.prefetchQuery({
    queryKey: ['chats', params.id, 'messages'],
    queryFn: () => fetchChatMessages(params.id),
  });

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <ChatView chatId={params.id} />
    </HydrationBoundary>
  );
}
```

### Reuse Queries Instead of React Context

Avoid React Context for data sharing. Use TanStack Query to share data across components:

```typescript
// ❌ Bad: Creating context for data
const UserContext = createContext();

// ✅ Good: Reuse query across components
// lib/user.query.ts
export function useCurrentUser() {
  return useQuery({
    queryKey: ['currentUser'],
    queryFn: () => apiClient.get('/auth/me'),
  });
}

// Multiple components can use the same query
function Header() {
  const { data: user, isPending } = useCurrentUser();
  if (isPending) return <HeaderSkeleton />;
  return <div>{user?.name}</div>;
}

function Sidebar() {
  const { data: user, isPending } = useCurrentUser(); // Same data, cached
  if (isPending) return <SidebarSkeleton />;
  return <div>{user?.email}</div>;
}
```

### Prefer Queries Over Prop Drilling

When a component needs data that's available via a TanStack Query hook, use the hook directly rather than prop drilling:

```typescript
// ❌ Bad: Prop drilling computed data
function ParentComponent() {
  const { data: servers } = useMcpServers();
  const { data: teams } = useTeams();

  // Computing derived data in parent
  const hasPersonalInstallation = servers?.some(s => s.ownerId === userId && !s.teamId);
  const availableTeams = teams?.filter(t => !usedTeamIds.includes(t.id));

  return (
    <ChildComponent
      hasPersonalInstallation={hasPersonalInstallation}
      availableTeams={availableTeams}
      // ... many more props
    />
  );
}

// ✅ Good: Child component fetches its own data
function ParentComponent() {
  return <ChildComponent catalogId={catalogId} />;  // Pass only identifier
}

function ChildComponent({ catalogId }: Props) {
  const { data: servers } = useMcpServers();  // Query directly
  const { data: teams } = useTeams();          // Query directly

  // Compute derived data locally
  const hasPersonalInstallation = servers?.some(s => s.catalogId === catalogId && !s.teamId);
  const availableTeams = teams?.filter(t => !usedTeamIds.includes(t.id));

  return <div>...</div>;
}
```

TanStack Query's built-in caching ensures no duplicate network requests when multiple components use the same query.

### Handle Toasts in Query Files, Not Components

**ALWAYS handle toast notifications in `.query.ts` files**, not in components. This centralizes error handling and ensures consistent user feedback:

```typescript
// ❌ Bad: Toast handling in component
function MyComponent() {
  const mutation = useUpdateSomething();

  const handleClick = () => {
    mutation.mutate(data, {
      onError: (error) => {
        toast.error(`Failed: ${error.message}`);  // Don't do this!
      },
    });
  };
}

// ✅ Good: Toast handling in query file
// lib/something.query.ts
export function useUpdateSomething() {
  return useMutation({
    mutationFn: async (data) => { ... },
    onSuccess: () => {
      toast.success("Updated successfully");
    },
    onError: (error) => {
      toast.error(`Failed to update: ${error instanceof Error ? error.message : "Unknown error"}`);
    },
  });
}

// Component just calls the mutation
function MyComponent() {
  const mutation = useUpdateSomething();
  const handleClick = () => mutation.mutate(data);
}
```

This pattern:
- Centralizes error handling logic
- Ensures consistent error messages
- Keeps components focused on UI concerns
- Makes testing easier

### Never Throw on HTTP Errors

**NEVER throw errors on HTTP failures in query/mutation functions.** Instead, use `handleApiError` for user notification and return appropriate default values:

```typescript
// ❌ Bad: Throwing on API errors
export function useSomething() {
  return useQuery({
    queryKey: ['something'],
    queryFn: async () => {
      const { data, error } = await getSomething();
      if (error) {
        throw new Error(error.message);  // Don't throw!
      }
      return data;
    },
  });
}

// ✅ Good: Toast + return default value
import { handleApiError } from "./utils";

export function useSomething() {
  return useQuery({
    queryKey: ['something'],
    queryFn: async () => {
      const { data, error } = await getSomething();
      if (error) {
        handleApiError(error);
        return [];  // Return appropriate default ([], null, {})
      }
      return data ?? [];
    },
  });
}

// ✅ Good: Mutation with error handling
export function useUpdateSomething() {
  return useMutation({
    mutationFn: async (input: UpdateInput) => {
      const { data, error } = await updateSomething(input);
      if (error) {
        handleApiError(error);
        return null;
      }
      return data;
    },
    onSuccess: () => {
      toast.success("Updated successfully");
    },
    // No onError needed - handled in mutationFn
  });
}
```

**Key rules:**
- Use `handleApiError(error)` for consistent error toasts
- Return appropriate defaults: `[]` for lists, `null` for single items, `{}` for objects
- **No try/catch in components** - all API error handling belongs in `.query.ts` files
- Remove `onError` callbacks that duplicate toast logic from mutationFn

## shadcn/ui Components

**ALWAYS use shadcn/ui** instead of direct Radix UI:

```bash
# Add components via CLI
npx shadcn@latest add button
npx shadcn@latest add dialog
npx shadcn@latest add form
```

Import from the components directory:
```typescript
import { Button } from '@/components/ui/button';
import { Dialog } from '@/components/ui/dialog';
```

### Use UI Components Over Plain HTML Elements

**ALWAYS use components from `@/components/ui` over plain HTML elements.** Never use raw `<button>`, `<input>`, `<select>`, etc. when a component exists in `frontend/src/components/ui`:

```typescript
// ❌ Bad: Plain HTML button
<button type="button" className="..." onClick={handleClick}>
  Click me
</button>

// ✅ Good: shadcn/ui Button
<Button variant="ghost" onClick={handleClick}>
  Click me
</Button>

// ❌ Bad: Plain HTML input
<input type="text" className="..." value={value} onChange={handleChange} />

// ✅ Good: shadcn/ui Input
<Input value={value} onChange={handleChange} />
```

This ensures consistent styling, accessibility, and theming across the application.

## Error Handling and Loading States

### Use Error Boundaries

Use the error boundary from components for handling errors:

```typescript
// app/chat/error.tsx
'use client';

export default function ChatError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```

### Handle Loading States Explicitly

Use `LoadingWrapper` or inline checks instead of Suspense for loading states:

```typescript
// app/chat/[id]/page.client.tsx
'use client';

import { LoadingWrapper } from '@/components/loading-wrapper';
import { ChatSkeleton } from './chat-skeleton';

export function ChatPage({ chatId }: { chatId: string }) {
  const { data, isPending, error } = useChatMessages(chatId);

  return (
    <LoadingWrapper isPending={isPending} error={error} skeleton={<ChatSkeleton />}>
      <ChatMessages messages={data ?? []} />
    </LoadingWrapper>
  );
}

// Alternative - inline for simple cases
export function ChatPage({ chatId }: { chatId: string }) {
  const { data, isPending } = useChatMessages(chatId);

  if (isPending) return <ChatSkeleton />;

  return <ChatMessages messages={data ?? []} />;
}
```

## Styling

Use Tailwind CSS 4 utility classes with consistent theming:

### Prioritize Global Theme Colors

Apply colors via global theme rather than inline in components:

```typescript
// ❌ Bad: Hardcoded colors
<div className="bg-blue-500 text-white">...</div>

// ✅ Good: Use theme colors
<div className="bg-primary text-primary-foreground">...</div>
<div className="bg-secondary text-secondary-foreground">...</div>
<div className="bg-destructive text-destructive-foreground">...</div>
```

### Conditional Classes

Use the `cn()` utility for conditional classes:

```typescript
import { cn } from '@/lib/utils';

export function Component({ className, variant }: Props) {
  return (
    <div
      className={cn(
        'rounded-lg p-4',
        variant === 'primary' && 'bg-primary text-primary-foreground',
        variant === 'secondary' && 'bg-secondary text-secondary-foreground',
        className
      )}
    />
  );
}
```

## File Organization

### Avoid Unnecessary Exports

Only export what needs to be used by other modules. If something is only used within the file, don't export it:

```typescript
// ❌ Bad: Exporting internal helpers
export function formatDate(date: Date): string { ... }
export function validateEmail(email: string): boolean { ... }
export function UserProfile({ user }: Props) {
  return <div>{formatDate(user.createdAt)}</div>;
}

// ✅ Good: Only export what's needed externally
function formatDate(date: Date): string { ... }  // Internal helper, not exported
function validateEmail(email: string): boolean { ... }  // Internal helper, not exported

export function UserProfile({ user }: Props) {  // Public API, exported
  return <div>{formatDate(user.createdAt)}</div>;
}
```

### Avoid Index and Barrel Files

Don't create index files that re-export multiple modules. Import directly from source files:

```typescript
// ❌ Bad: Barrel file
// components/index.ts
export { Button } from './button';
export { Dialog } from './dialog';

// ❌ Bad: Importing from barrel
import { Button, Dialog } from './components';

// ✅ Good: Direct imports
import { Button } from './components/button';
import { Dialog } from './components/dialog';
```

### Promote Feature Colocation

Group related files by feature/domain in flat structure:

```
lib/
├── chat.query.ts        # TanStack Query hooks for chat
├── chat.utils.ts        # Pure functions for chat logic
├── chat.hook.ts         # Custom React hooks for chat
├── chat.types.ts        # TypeScript types for chat
├── user.query.ts        # User-related queries
├── user.utils.ts        # User utility functions
└── api-client.ts        # Shared API client
```

Avoid unnecessary nested folders:

```typescript
// ❌ Bad: Unnecessary nesting
lib/chat/queries/use-chat-messages.ts
lib/chat/utils/format-message.ts
lib/chat/hooks/use-chat-state.ts

// ✅ Good: Flat, feature-based
lib/chat.query.ts
lib/chat.utils.ts
lib/chat.hook.ts
```

## Form Handling with react-hook-form

**ALWAYS use react-hook-form** for form state management instead of multiple `useState` hooks:

### Pass Form to Child Components

```typescript
// ❌ Bad: Multiple useState hooks
function MyForm() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  // ... more states
}

// ✅ Good: Use useForm and pass form to child components
import { useForm, UseFormReturn } from "react-hook-form";

type FormValues = {
  name: string;
  email: string;
  phone: string;
};

// Parent component owns the form
function ParentComponent() {
  const form = useForm<FormValues>({
    defaultValues: { name: "", email: "", phone: "" },
  });
  const mutation = useCreateSomething();

  const handleSubmit = form.handleSubmit(async (values) => {
    await mutation.mutateAsync(values);
    form.reset();
  });

  return (
    <>
      <MyFormFields form={form} isPending={mutation.isPending} />
      <Button onClick={handleSubmit} disabled={mutation.isPending}>Submit</Button>
    </>
  );
}

// Child component renders form fields
interface MyFormFieldsProps {
  form: UseFormReturn<FormValues>;
  isPending?: boolean;
}

function MyFormFields({ form, isPending }: MyFormFieldsProps) {
  return (
    <div>
      <Input {...form.register("name")} disabled={isPending} />
      <Input {...form.register("email")} disabled={isPending} />
    </div>
  );
}
```

### Parent Controls Mutations and Submission

Keep mutations in parent components. Form components focus on rendering fields only:

```typescript
// ❌ Bad: Mutation inside form component
function FormComponent() {
  const mutation = useCreateItem();  // Don't put mutations here
  const handleSubmit = () => mutation.mutate(data);
  return <form onSubmit={handleSubmit}>...</form>;
}

// ✅ Good: Parent handles mutations
function ParentComponent() {
  const form = useForm<FormValues>();
  const mutation = useCreateItem();

  const handleSubmit = form.handleSubmit(async (values) => {
    await mutation.mutateAsync(values);
  });

  return (
    <>
      <FormFields form={form} isPending={mutation.isPending} />
      <Button onClick={handleSubmit}>Submit</Button>
    </>
  );
}

function FormFields({ form, isPending }: Props) {
  // Pure rendering, no mutations
  return <Input {...form.register("name")} disabled={isPending} />;
}
```

## Reuse API Types from @shared

**ALWAYS reuse types from `archestraApiTypes`** instead of defining duplicate types:

```typescript
// ❌ Bad: Defining duplicate types
type CreateItemPayload = {
  name: string;
  description?: string;
  scope: "personal" | "team" | "org_wide";
};

// ✅ Good: Reuse from generated API types
import { type archestraApiTypes } from "@shared";

type CreateItemBody = archestraApiTypes.CreateItemData["body"];
type ItemResponse = archestraApiTypes.GetItemsResponses["200"][number];

// For form values, derive from API types
type ItemFormValues = {
  name: string;
  description: string;
  scope: NonNullable<CreateItemBody["scope"]>;
};
```

Common patterns:
- `archestraApiTypes.CreateXxxData["body"]` - Request body type for create endpoints
- `archestraApiTypes.UpdateXxxData["body"]` - Request body type for update endpoints
- `archestraApiTypes.GetXxxResponses["200"]` - Response type for list endpoints
- `archestraApiTypes.GetXxxResponses["200"][number]` - Single item from list response

## Next.js App Router

- Use file-based routing in `src/app/`
- `page.tsx` for routes
- `layout.tsx` for shared layouts
- `loading.tsx` for loading states (prefer Suspense)
- `error.tsx` for error boundaries
- Use `generateMetadata` for SEO

Example page structure:
```typescript
// app/dashboard/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Dashboard',
  description: 'User dashboard',
};

export default async function DashboardPage() {
  const data = await fetchDashboardData();
  return <DashboardView data={data} />;
}
```

## Summary of Key Practices

1. ✅ Extract pure functions from components
2. ✅ Create small, focused components (especially for array.map items)
3. ✅ Use shadcn/ui, avoid direct Radix UI
4. ✅ Use shadcn/ui components over plain HTML elements (Button over button, Input over input, etc.)
5. ✅ Use TanStack Query with useQuery and explicit loading states (LoadingWrapper or inline)
6. ✅ Handle toast notifications in .query.ts files, not in components
7. ✅ Never throw on HTTP errors - use `handleApiError` and return defaults
8. ✅ Use error boundaries for error handling
9. ✅ Handle loading states explicitly with LoadingWrapper or inline checks
10. ✅ Prefetch data on server, pass as initial data to queries
11. ✅ Avoid index/barrel files - use direct imports
12. ✅ Use flat, feature-based file colocation (e.g., chat.query.ts, chat.utils.ts)
13. ✅ Apply colors via global theme, not inline
14. ✅ Avoid React Context - use TanStack Query for shared data
15. ✅ Extract business logic to pure functions or queries
16. ✅ Only export what needs to be used by other modules - keep internal helpers private
17. ✅ Prefer TanStack Query hooks over prop drilling - pass only identifiers, let components fetch their own data
18. ✅ Use react-hook-form for forms - pass form object to child components, parent handles mutations
19. ✅ Reuse API types from archestraApiTypes (e.g., CreateXxxData["body"]) instead of defining duplicate types
