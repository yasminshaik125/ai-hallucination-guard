---
description: Core project conventions and working directory rules for Archestra Platform
alwaysApply: true
---

# Project Conventions

**⚠️ IMPORTANT: Keep .cursor/rules/ in sync with CLAUDE.md. When updating one, update the other.**

## Working Directory

**ALWAYS run all commands from the `platform/` directory unless specifically instructed otherwise.**

## Package Management

**ALWAYS use pnpm** (not npm or yarn) for all package management operations:
- Install: `pnpm install`
- Add dependencies: `pnpm add <package>`
- Run scripts: `pnpm <script-name>`

## Code Quality Standards

1. **TypeScript strict mode** - Ensure code passes `pnpm type-check` before completion
2. **Biome for linting and formatting** - Run `pnpm lint` before committing changes
3. **Testing** - Use Vitest with PGLite for backend tests
4. Test files should be colocated with source (`.test.ts` extension)

## Naming Conventions

- Use **camelCase** for TypeScript variables, functions, and properties
- Use **PascalCase** for TypeScript classes, interfaces, and types
- Use **kebab-case** for file names (e.g., `tool-invocation-policy.ts`)
- Use workspace-relative imports within each workspace

## Function Parameters

- **If a function accepts more than 2 parameters**, use a single object parameter instead of multiple positional parameters
- This improves readability, makes parameters self-documenting, and allows for easier future extension

```typescript
// Good
async function validateScope(params: {
  scope: string;
  teamId: string | null;
  userId: string;
}): Promise<void> { ... }

// Avoid
async function validateScope(
  scope: string,
  teamId: string | null,
  userId: string
): Promise<void> { ... }
```

## Classes vs Module Functions

- **Prefer classes for stateful modules**: When encapsulating functionality that involves state (cached values, intervals, connections), use a class with a singleton instance instead of module-level variables with loose functions
- This improves encapsulation, testability, and makes state management explicit

```typescript
// Good - class with singleton
class ChatOpsManager {
  private provider: Provider | null = null;

  initialize() { ... }
  cleanup() { ... }
}
export const chatOpsManager = new ChatOpsManager();

// Avoid - module-level state with loose functions
let provider: Provider | null = null;
export function initialize() { ... }
export function cleanup() { ... }
```

## Private Methods

- **Mark methods as `private`** if they are only used within the class
- **Place private methods at the bottom** of the class, after all public methods
- This keeps the "public interface" visible at the top of the class

```typescript
class MyService {
  // Public methods first
  doSomething() {
    this.helperA();
  }

  // Private methods at bottom
  private helperA() { ... }
  private helperB() { ... }
}
```

## Export Discipline

- **CRITICAL: Only export what is actually used outside the module**
- If a function, constant, or type is only used within the module, do NOT export it
- Avoid "just in case" exports - they pollute the public API and create unnecessary coupling

```typescript
// Good - only export what's needed externally
export const myService = new MyService();

// Bad - exporting internal helpers
export function internalHelper() { ... }  // Not used outside!
export const INTERNAL_CONSTANT = 42;      // Not used outside!
```

## Module Code Order (CRITICAL)

**⚠️ ALWAYS structure files with exports at TOP, internal helpers at BOTTOM.**

- Structure modules so the **public interface appears at the top**
- Internal/private functions, interfaces, and constants go at the **bottom** of the file
- Use section comments (`// ===`) to clearly separate public and private sections
- This makes it immediately clear what the module exposes
- Function declarations are hoisted in JavaScript, so helpers can be called before they're defined

```typescript
// 1. Imports
import { something } from "somewhere";

// =============================================================================
// Exported Items (Public Interface)
// =============================================================================

export function publicFunctionA() {
  return helperB();  // Can call helper defined below (hoisting)
}

export const publicConstant = "value";

export default publicFunctionA;

// =============================================================================
// Internal Helpers (not exported)
// =============================================================================

interface InternalType {
  value: number;
}

function helperB() {
  return helperC();
}

function helperC() {
  return INTERNAL_CONFIG.value;
}

const INTERNAL_CONFIG: InternalType = { value: 42 };
```

## Error Handling in Routes

- **Always use `throw new ApiError(statusCode, message)`** for error responses
- **Never use manual `reply.status().send({ error: ... })`** - this bypasses centralized error handling
- The Fastify error handler formats all errors consistently and logs appropriately

```typescript
// ❌ Bad - manual error response
if (!provider) {
  return reply.status(400).send({ error: "Provider not configured" });
}

// ✅ Good - use ApiError
if (!provider) {
  throw new ApiError(400, "Provider not configured");
}
```

## Protected Routes & Authentication

- Routes under `/api/` are protected by the auth middleware which guarantees `request.user` and `request.organizationId` exist
- **Never add redundant null checks** for authentication - the middleware handles it
- Routes handle authorization and business logic, not authentication

```typescript
// ❌ Bad - redundant authentication check
async (request, reply) => {
  if (!request.organizationId) {
    throw new ApiError(401, "Unauthorized");
  }
  const data = await Model.findByOrganization(request.organizationId);
  return reply.send(data);
}

// ✅ Good - trust the middleware, use directly
async (request, reply) => {
  const data = await Model.findByOrganization(request.organizationId);
  return reply.send(data);
}
```

## Database Types via drizzle-zod

- **Never manually define TypeScript interfaces for database entities**
- Use `drizzle-zod` to generate Zod schemas from Drizzle table definitions
- Infer types with `z.infer<>` to keep types in sync with the schema automatically
- Place these in `backend/src/types/<entity>.ts`

```typescript
// In types/<entity>.ts
import { createSelectSchema, createInsertSchema, createUpdateSchema } from "drizzle-zod";
import type { z } from "zod";
import { schema } from "@/database";

// Generate schemas from Drizzle table
export const SelectEntitySchema = createSelectSchema(schema.entityTable);
export const InsertEntitySchema = createInsertSchema(schema.entityTable).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});
export const UpdateEntitySchema = createUpdateSchema(schema.entityTable).pick({
  fieldToUpdate: true,
});

// Infer types from schemas
export type Entity = z.infer<typeof SelectEntitySchema>;
export type InsertEntity = z.infer<typeof InsertEntitySchema>;
export type UpdateEntity = z.infer<typeof UpdateEntitySchema>;
```

**Benefits:**
- Single source of truth (Drizzle schema)
- Types automatically stay in sync with database schema
- Zod schemas can be used for runtime validation
- No manual type maintenance required
