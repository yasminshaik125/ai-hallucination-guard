// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};

export type OpenAiChatCompletionRequestInput = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type OpenAiChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type GeminiGenerateContentRequestInput = {
    /**
     * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries like chat, this is a repeated field that contains the conversation history and the latest request
     */
    contents: Array<{
        /**
         * The role of the author of this content.
         */
        role: string;
        parts: Array<{
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            text: string;
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            inlineData: {
                mimeType?: string;
                data: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            functionCall: {
                id?: string;
                name: string;
                args?: {
                    [key: string]: unknown;
                };
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            functionResponse: {
                id?: string;
                name: string;
                response: {
                    [key: string]: unknown;
                };
                willContinue?: boolean;
                scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            fileData: {
                mimeType?: string;
                fileUri: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
            executableCode: {
                code: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            codeExecutionResult: {
                /**
                 * Outcome of the code execution.
                 */
                outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                output?: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        }>;
    }>;
    /**
     * A list of Tools the Model may use to generate the next response. A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the Model. Supported Tools are Function and codeExecution. Refer to the Function calling and the Code execution guides to learn more.
     */
    tools?: Array<{
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    }> | {
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    };
    /**
     * Tool configuration for any Tool specified in the request.
     */
    toolConfig?: {
        functionCallingConfig: {
            mode: 'AUTO' | 'ANY' | 'NONE';
            allowedFunctionNames?: Array<string>;
        };
    };
    /**
     * A list of unique SafetySetting instances for blocking unsafe content.
     */
    safetySettings?: Array<{
        /**
         *
         * The category for this setting
         *
         * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
         *
         */
        category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
        /**
         *
         * Controls the probability threshold at which harm is blocked.
         *
         * https://ai.google.dev/api/generate-content#HarmBlockThreshold
         *
         */
        threshold: 'HARM_BLOCK_THRESHOLD_UNSPECIFIED' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_ONLY_HIGH' | 'BLOCK_NONE' | 'OFF';
    }>;
    /**
     * Developer set system instruction(s). Currently, text only.
     */
    systemInstruction?: {
        parts: Array<{
            text: string;
        }>;
    };
    /**
     * https://ai.google.dev/api/generate-content#v1beta.GenerationConfig
     */
    generationConfig?: {
        stopSequences?: Array<string>;
        responseMimeType?: string;
        responseSchema?: unknown;
        _responseJsonSchema?: unknown;
        responseJsonSchema?: unknown;
        responseModalities?: Array<'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO'>;
        candidateCount?: number;
        maxOutputTokens?: number;
        temperature?: number;
        topP?: number;
        topK?: number;
        seed?: number;
        presencePenalty?: number;
        frequencyPenalty?: number;
        responseLogprobs?: boolean;
        logProbs?: number;
        enableEnhancedCivicAnswers?: boolean;
        speechConfig?: unknown;
        thinkingConfig?: unknown;
        imageConfig?: unknown;
        /**
         * https://ai.google.dev/api/generate-content#MediaResolution
         */
        mediaResolution?: 'MEDIA_RESOLUTION_UNSPECIFIED' | 'MEDIA_RESOLUTION_LOW' | 'MEDIA_RESOLUTION_MEDIUM' | 'MEDIA_RESOLUTION_HIGH';
    };
    /**
     * The name of the content cached to use as context to serve the prediction. Format: cachedContents/{cachedContent}
     */
    cachedContent?: string;
    config?: {
        tools?: Array<{
            functionDeclarations?: Array<{
                /**
                 * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                 */
                name: string;
                /**
                 * A brief description of the function.
                 */
                description: string;
                /**
                 * https://ai.google.dev/api/caching#Behavior
                 */
                behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
                /**
                 * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                parametersJsonSchema?: unknown;
                response?: unknown;
                responseJsonSchema?: unknown;
            }>;
            /**
             * https://ai.google.dev/api/caching#GoogleSearchRetrieval
             */
            googleSearchRetrieval?: {
                /**
                 *
                 * Specifies the dynamic retrieval configuration for the given source.
                 *
                 * https://ai.google.dev/api/caching#DynamicRetrievalConfig
                 *
                 */
                dynamicRetrievalConfig: {
                    /**
                     * https://ai.google.dev/api/caching#Mode
                     */
                    mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                    dynamicThreshold: number;
                };
            };
            codeExecution?: unknown;
            googleSearch?: unknown;
            urlContext?: unknown;
        }> | {
            functionDeclarations?: Array<{
                /**
                 * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                 */
                name: string;
                /**
                 * A brief description of the function.
                 */
                description: string;
                /**
                 * https://ai.google.dev/api/caching#Behavior
                 */
                behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
                /**
                 * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                parametersJsonSchema?: unknown;
                response?: unknown;
                responseJsonSchema?: unknown;
            }>;
            /**
             * https://ai.google.dev/api/caching#GoogleSearchRetrieval
             */
            googleSearchRetrieval?: {
                /**
                 *
                 * Specifies the dynamic retrieval configuration for the given source.
                 *
                 * https://ai.google.dev/api/caching#DynamicRetrievalConfig
                 *
                 */
                dynamicRetrievalConfig: {
                    /**
                     * https://ai.google.dev/api/caching#Mode
                     */
                    mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                    dynamicThreshold: number;
                };
            };
            codeExecution?: unknown;
            googleSearch?: unknown;
            urlContext?: unknown;
        };
        /**
         * Tool configuration for any Tool specified in the request.
         */
        toolConfig?: {
            functionCallingConfig: {
                mode: 'AUTO' | 'ANY' | 'NONE';
                allowedFunctionNames?: Array<string>;
            };
        };
    };
};

export type GeminiGenerateContentResponseInput = {
    /**
     * Candidate responses from the model
     */
    candidates: Array<{
        /**
         *
         * The base structured datatype containing multi-part content of a message.
         *
         * A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that contains the content of the message turn.
         *
         * https://ai.google.dev/api/caching#Content
         *
         */
        content: {
            /**
             * The role of the author of this content.
             */
            role: string;
            parts: Array<{
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                text: string;
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                inlineData: {
                    mimeType?: string;
                    data: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                functionCall: {
                    id?: string;
                    name: string;
                    args?: {
                        [key: string]: unknown;
                    };
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                functionResponse: {
                    id?: string;
                    name: string;
                    response: {
                        [key: string]: unknown;
                    };
                    willContinue?: boolean;
                    scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                fileData: {
                    mimeType?: string;
                    fileUri: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                executableCode: {
                    code: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                codeExecutionResult: {
                    /**
                     * Outcome of the code execution.
                     */
                    outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                    output?: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            }>;
        };
        /**
         *
         * The reason why the model stopped generating tokens.
         *
         * If empty, the model has not stopped generating tokens.
         *
         * https://ai.google.dev/api/generate-content#FinishReason
         *
         */
        finishReason?: 'FINISH_REASON_UNSPECIFIED' | 'STOP' | 'MAX_TOKENS' | 'SAFETY' | 'RECITATION' | 'LANGUAGE' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'SPII' | 'MALFORMED_FUNCTION_CALL' | 'IMAGE_SAFETY' | 'IMAGE_PROHIBITED_CONTENT' | 'IMAGE_OTHER' | 'NO_IMAGE' | 'IMAGE_RECITATION' | 'UNEXPECTED_TOOL_CALL' | 'TOO_MANY_TOOL_CALLS';
        safetyRatings?: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked?: boolean;
        }>;
        /**
         * https://ai.google.dev/api/generate-content#citationmetadata
         */
        citationMetadata?: {
            citationSources: Array<{
                startIndex?: number;
                endIndex?: number;
                uri?: string;
                license?: string;
            }>;
        };
        tokenCount?: number;
        groundingAttributions?: Array<unknown>;
        groundingMetadata?: unknown;
        avgLogprobs?: number;
        logprobsResult?: unknown;
        urlContextMetadata?: unknown;
        /**
         * Index of the candidate in the list of response candidates.
         */
        index: number;
        /**
         * Details the reason why the model stopped generating tokens. This is populated only when finishReason is set.
         */
        finishMessage?: string;
    }>;
    /**
     * Returns the prompt's feedback related to the content filters
     */
    promptFeedback?: {
        /**
         * Specifies the reason why the prompt was blocked. https://ai.google.dev/api/generate-content#BlockReason
         */
        blockReason?: 'BLOCK_REASON_UNSPECIFIED' | 'SAFETY' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'IMAGE_SAFETY';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked?: boolean;
        }>;
    };
    /**
     * Metadata on the generation requests' token usage
     */
    usageMetadata?: {
        promptTokenCount?: number;
        cachedContentTokenCount?: number;
        candidatesTokenCount?: number;
        toolUsePromptTokenCount?: number;
        thoughtsTokenCount?: number;
        totalTokenCount?: number;
        promptTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        cacheTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        candidatesTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        toolUsePromptTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
    };
    /**
     * The model version used to generate the response.
     */
    modelVersion?: string;
    /**
     * The unique response ID.
     */
    responseId?: string;
};

export type AnthropicMessagesRequestInput = {
    model: string;
    messages: Array<{
        content: string | Array<{
            text: string;
            type: 'text';
            cache_control?: unknown;
            citations?: Array<unknown> | unknown;
        } | {
            type: 'image';
            source: {
                type: 'base64';
                media_type: string;
                data: string;
            };
            cache_control?: unknown;
        } | {
            id: string;
            input: unknown;
            name: string;
            type: 'tool_use';
            cache_control?: unknown;
        } | {
            tool_use_id: string;
            type: 'tool_result';
            cache_control?: unknown;
            content?: string | Array<{
                text: string;
                type: 'text';
                cache_control?: unknown;
                citations?: Array<unknown> | unknown;
            } | {
                type: 'image';
                source: {
                    type: 'base64';
                    media_type: string;
                    data: string;
                };
                cache_control?: unknown;
            }>;
            is_error?: boolean;
        }>;
        role: 'user' | 'assistant';
    }>;
    max_tokens: number;
    container?: string | unknown;
    context_management?: {
        [key: string]: unknown;
    } | unknown;
    mcp_servers?: Array<unknown>;
    metadata?: {
        user_id: string | unknown;
    };
    service_tier?: unknown;
    stop_sequences?: Array<string>;
    stream?: boolean;
    system?: string | {
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    } | Array<{
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    }>;
    temperature?: number;
    tool_choice?: {
        type: 'auto';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'any';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'tool';
        name: string;
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'none';
    };
    tools?: Array<{
        name: string;
        type?: 'custom' | unknown;
        cache_control?: unknown;
        input_schema: {
            [key: string]: unknown;
        };
        description?: string;
    } | {
        name: 'bash';
        type: 'bash_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_editor';
        type: 'text_editor_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250429';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250728';
        cache_control?: unknown;
        max_characters?: number | unknown;
    } | {
        name: 'web_search';
        type: 'web_search_20250305';
        allowed_domains?: Array<string> | unknown;
        blocked_domains?: Array<string> | unknown;
        cache_control?: unknown;
        max_uses?: number | unknown;
        user_location?: unknown;
    }>;
    top_k?: number;
    top_p?: number;
};

export type AnthropicMessagesResponseInput = {
    id: string;
    content: Array<{
        citations: Array<unknown> | unknown;
        text: string;
        type: 'text';
    } | {
        id: string;
        input: unknown;
        name: string;
        type: 'tool_use';
    }>;
    model: string;
    role: 'assistant';
    stop_reason: unknown;
    stop_sequence: string | unknown;
    type: 'message';
    usage: {
        input_tokens: number;
        output_tokens: number;
    };
};

export type CerebrasChatCompletionRequestInput = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type CerebrasChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/Cerebras/cerebras-cloud-sdk-node/blob/main/src/resources/chat/completions.ts
         */
        message: {
            content?: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type CohereChatRequestInput = {
    model: string;
    messages: Array<{
        role: string;
        content: string | Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
    } | {
        role: string;
        content?: string | Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
        tool_calls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
    } | {
        role: string;
        content: string;
    } | {
        role: string;
        tool_call_id: string;
        content: string;
    }>;
    stream?: boolean;
    temperature?: number;
    max_tokens?: number;
    tools?: Array<{
        type: string;
        function: {
            name: string;
            description?: string;
            parameters?: {
                type: string;
                description?: string;
                required?: Array<string>;
                properties?: {
                    [key: string]: unknown;
                };
            };
        };
    }>;
    tool_choice?: 'REQUIRED' | 'NONE';
    safety_mode?: 'CONTEXTUAL' | 'STRICT' | 'OFF';
    response_format?: {
        type: 'json_object' | 'text';
        json_schema?: {
            [key: string]: unknown;
        };
    };
    frequency_penalty?: number;
    presence_penalty?: number;
    k?: number;
    p?: number;
    seed?: number;
    stop_sequences?: Array<string>;
    logprobs?: boolean;
};

export type CohereChatResponseInput = {
    id: string;
    message: {
        role: string;
        content?: Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
        tool_calls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
    };
    finish_reason: 'COMPLETE' | 'MAX_TOKENS' | 'STOP_SEQUENCE' | 'TOOL_CALL' | 'ERROR';
    usage?: {
        billed_units?: {
            input_tokens?: number;
            output_tokens?: number;
        };
        tokens?: {
            input_tokens?: number;
            output_tokens?: number;
        };
    };
};

export type MistralChatCompletionRequestInput = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type MistralChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
    [key: string]: unknown | string | Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }> | number | 'chat.completion' | string | unknown | {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    } | undefined;
};

export type VllmChatCompletionRequestInput = {
    model: string;
    /**
     * A message in the conversation
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * Audio input details
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * File details
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * A tool call in the assistant message
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * Function call details
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * Custom tool call details
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
        reasoning?: string | unknown;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     * A tool definition
     */
    tools?: Array<{
        type: 'function';
        /**
         * A function definition for tool calling
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * The parameters the functions accepts, described as a JSON Schema object.
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * Tool choice option
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * Allowed tools configuration
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model.
             * auto: allows the model to pick from allowed tools or generate a message.
             * required: requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * A function definition for tool calling
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * The parameters the functions accepts, described as a JSON Schema object.
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
    top_p?: number | unknown;
    top_k?: number | unknown;
    frequency_penalty?: number | unknown;
    presence_penalty?: number | unknown;
    repetition_penalty?: number | unknown;
    stop?: string | Array<string>;
    seed?: number | unknown;
    n?: number | unknown;
    best_of?: number | unknown;
    logprobs?: boolean | unknown;
    top_logprobs?: number | unknown;
};

export type VllmChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * The assistant message in the response
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * A tool call in the assistant message
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * Function call details
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * Custom tool call details
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
            reasoning?: string | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * Token usage statistics for the completion
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        completion_tokens_details?: unknown;
        prompt_tokens_details?: unknown;
    };
};

export type OllamaChatCompletionRequestInput = {
    model: string;
    /**
     * A message in the conversation
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * Audio input details
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * File details
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * A tool call in the assistant message
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * Function call details
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * Custom tool call details
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     * A tool definition
     */
    tools?: Array<{
        type: 'function';
        /**
         * A function definition for tool calling
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * The parameters the functions accepts, described as a JSON Schema object.
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * Tool choice option
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * Allowed tools configuration
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model.
             * auto: allows the model to pick from allowed tools or generate a message.
             * required: requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * A function definition for tool calling
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * The parameters the functions accepts, described as a JSON Schema object.
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
    top_p?: number | unknown;
    frequency_penalty?: number | unknown;
    presence_penalty?: number | unknown;
    stop?: string | Array<string>;
    seed?: number | unknown;
    n?: number | unknown;
};

export type OllamaChatCompletionResponseInput = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * The assistant message in the response
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * A tool call in the assistant message
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * Function call details
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * Custom tool call details
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * Token usage statistics for the completion
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        completion_tokens_details?: unknown;
        prompt_tokens_details?: unknown;
    };
};

export type ZhipuaiChatCompletionRequestInput = {
    model: string;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#body
     */
    messages: Array<{
        role: 'system';
        content: string;
        name?: string;
    } | {
        role: 'user';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://docs.z.ai/api-reference/llm/chat-completion#body
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        name?: string;
    } | {
        role: 'assistant';
        content?: string | unknown;
        name?: string;
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://docs.z.ai/api-reference/llm/chat-completion#response
             */
            function: {
                arguments: string;
                name: string;
            };
        }>;
        function_call?: {
            arguments: string;
            name: string;
        };
    } | {
        role: 'tool';
        content: string;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string;
        name: string;
    }>;
    tools?: Array<{
        type: 'function';
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#body
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://docs.z.ai/api-reference/llm/chat-completion#body
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    }>;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#body
     */
    tool_choice?: 'auto' | {
        type: 'function';
        function: {
            name: string;
        };
    };
    request_id?: string;
    do_sample?: boolean;
    stream?: boolean;
    thinking?: {
        type: 'enabled' | 'disabled';
        clear_thinking?: boolean;
    };
    temperature?: number | unknown;
    top_p?: number | unknown;
    max_tokens?: number | unknown;
    tool_stream?: boolean;
    stop?: Array<string>;
    response_format?: {
        type: 'text' | 'json_object';
    };
    user_id?: string;
};

export type ZhipuaiChatCompletionResponseInput = {
    id: string;
    request_id?: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'sensitive' | 'network_error';
        index: number;
        logprobs: unknown;
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#response
         */
        message: {
            content: string | unknown;
            role: 'assistant';
            reasoning_content?: string;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://docs.z.ai/api-reference/llm/chat-completion#response
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            }>;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#response
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#response
         */
        prompt_tokens_details?: {
            cached_tokens: number;
        };
    };
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#response
     */
    web_search?: Array<{
        title: string;
        content: string;
        link: string;
        media: string;
        icon: string;
        refer: string;
        publish_date: string;
    }>;
};

export type OpenAiChatCompletionRequest = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type OpenAiChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type GeminiGenerateContentRequest = {
    /**
     * The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries like chat, this is a repeated field that contains the conversation history and the latest request
     */
    contents: Array<{
        /**
         * The role of the author of this content.
         */
        role: string;
        parts: Array<{
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            text: string;
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            inlineData: {
                mimeType?: string;
                data: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            functionCall: {
                id?: string;
                name: string;
                args?: {
                    [key: string]: unknown;
                };
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            functionResponse: {
                id?: string;
                name: string;
                response: {
                    [key: string]: unknown;
                };
                willContinue?: boolean;
                scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            fileData: {
                mimeType?: string;
                fileUri: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
            executableCode: {
                code: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        } | {
            /**
             * Indicates if the part is thought from the model
             */
            thought?: boolean;
            /**
             * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
             */
            thoughtSignature?: string;
            codeExecutionResult: {
                /**
                 * Outcome of the code execution.
                 */
                outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                output?: string;
            };
            /**
             * https://ai.google.dev/api/caching#VideoMetadata
             */
            metadata?: {
                /**
                 * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                startOffset?: string;
                /**
                 * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                 */
                endOffset?: string;
                /**
                 * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                 */
                fps?: number;
            };
        }>;
    }>;
    /**
     * A list of Tools the Model may use to generate the next response. A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the Model. Supported Tools are Function and codeExecution. Refer to the Function calling and the Code execution guides to learn more.
     */
    tools?: Array<{
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    }> | {
        functionDeclarations?: Array<{
            /**
             * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
             */
            name: string;
            /**
             * A brief description of the function.
             */
            description: string;
            /**
             * https://ai.google.dev/api/caching#Behavior
             */
            behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
            /**
             * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
             */
            parameters?: {
                [key: string]: unknown;
            };
            parametersJsonSchema?: unknown;
            response?: unknown;
            responseJsonSchema?: unknown;
        }>;
        /**
         * https://ai.google.dev/api/caching#GoogleSearchRetrieval
         */
        googleSearchRetrieval?: {
            /**
             *
             * Specifies the dynamic retrieval configuration for the given source.
             *
             * https://ai.google.dev/api/caching#DynamicRetrievalConfig
             *
             */
            dynamicRetrievalConfig: {
                /**
                 * https://ai.google.dev/api/caching#Mode
                 */
                mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                dynamicThreshold: number;
            };
        };
        codeExecution?: unknown;
        googleSearch?: unknown;
        urlContext?: unknown;
    };
    /**
     * Tool configuration for any Tool specified in the request.
     */
    toolConfig?: {
        functionCallingConfig: {
            mode: 'AUTO' | 'ANY' | 'NONE';
            allowedFunctionNames?: Array<string>;
        };
    };
    /**
     * A list of unique SafetySetting instances for blocking unsafe content.
     */
    safetySettings?: Array<{
        /**
         *
         * The category for this setting
         *
         * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
         *
         */
        category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
        /**
         *
         * Controls the probability threshold at which harm is blocked.
         *
         * https://ai.google.dev/api/generate-content#HarmBlockThreshold
         *
         */
        threshold: 'HARM_BLOCK_THRESHOLD_UNSPECIFIED' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_ONLY_HIGH' | 'BLOCK_NONE' | 'OFF';
    }>;
    /**
     * Developer set system instruction(s). Currently, text only.
     */
    systemInstruction?: {
        parts: Array<{
            text: string;
        }>;
    };
    /**
     * https://ai.google.dev/api/generate-content#v1beta.GenerationConfig
     */
    generationConfig?: {
        stopSequences?: Array<string>;
        responseMimeType?: string;
        responseSchema?: unknown;
        _responseJsonSchema?: unknown;
        responseJsonSchema?: unknown;
        responseModalities?: Array<'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO'>;
        candidateCount?: number;
        maxOutputTokens?: number;
        temperature?: number;
        topP?: number;
        topK?: number;
        seed?: number;
        presencePenalty?: number;
        frequencyPenalty?: number;
        responseLogprobs?: boolean;
        logProbs?: number;
        enableEnhancedCivicAnswers?: boolean;
        speechConfig?: unknown;
        thinkingConfig?: unknown;
        imageConfig?: unknown;
        /**
         * https://ai.google.dev/api/generate-content#MediaResolution
         */
        mediaResolution?: 'MEDIA_RESOLUTION_UNSPECIFIED' | 'MEDIA_RESOLUTION_LOW' | 'MEDIA_RESOLUTION_MEDIUM' | 'MEDIA_RESOLUTION_HIGH';
    };
    /**
     * The name of the content cached to use as context to serve the prediction. Format: cachedContents/{cachedContent}
     */
    cachedContent?: string;
    config?: {
        tools?: Array<{
            functionDeclarations?: Array<{
                /**
                 * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                 */
                name: string;
                /**
                 * A brief description of the function.
                 */
                description: string;
                /**
                 * https://ai.google.dev/api/caching#Behavior
                 */
                behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
                /**
                 * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                parametersJsonSchema?: unknown;
                response?: unknown;
                responseJsonSchema?: unknown;
            }>;
            /**
             * https://ai.google.dev/api/caching#GoogleSearchRetrieval
             */
            googleSearchRetrieval?: {
                /**
                 *
                 * Specifies the dynamic retrieval configuration for the given source.
                 *
                 * https://ai.google.dev/api/caching#DynamicRetrievalConfig
                 *
                 */
                dynamicRetrievalConfig: {
                    /**
                     * https://ai.google.dev/api/caching#Mode
                     */
                    mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                    dynamicThreshold: number;
                };
            };
            codeExecution?: unknown;
            googleSearch?: unknown;
            urlContext?: unknown;
        }> | {
            functionDeclarations?: Array<{
                /**
                 * The name of the function. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 63.
                 */
                name: string;
                /**
                 * A brief description of the function.
                 */
                description: string;
                /**
                 * https://ai.google.dev/api/caching#Behavior
                 */
                behavior?: 'UNSPECIFIED' | 'BLOCKING' | 'NON_BLOCKING';
                /**
                 * Describes the parameters to this function. Reflects the Open API 3.03 Parameter Object string Key: the name of the parameter. Parameter names are case sensitive. Schema Value: the Schema defining the type used for the parameter.
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                parametersJsonSchema?: unknown;
                response?: unknown;
                responseJsonSchema?: unknown;
            }>;
            /**
             * https://ai.google.dev/api/caching#GoogleSearchRetrieval
             */
            googleSearchRetrieval?: {
                /**
                 *
                 * Specifies the dynamic retrieval configuration for the given source.
                 *
                 * https://ai.google.dev/api/caching#DynamicRetrievalConfig
                 *
                 */
                dynamicRetrievalConfig: {
                    /**
                     * https://ai.google.dev/api/caching#Mode
                     */
                    mode: 'MODE_UNSPECIFIED' | 'MODE_DYNAMIC';
                    dynamicThreshold: number;
                };
            };
            codeExecution?: unknown;
            googleSearch?: unknown;
            urlContext?: unknown;
        };
        /**
         * Tool configuration for any Tool specified in the request.
         */
        toolConfig?: {
            functionCallingConfig: {
                mode: 'AUTO' | 'ANY' | 'NONE';
                allowedFunctionNames?: Array<string>;
            };
        };
    };
};

export type GeminiGenerateContentResponse = {
    /**
     * Candidate responses from the model
     */
    candidates: Array<{
        /**
         *
         * The base structured datatype containing multi-part content of a message.
         *
         * A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that contains the content of the message turn.
         *
         * https://ai.google.dev/api/caching#Content
         *
         */
        content: {
            /**
             * The role of the author of this content.
             */
            role: string;
            parts: Array<{
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                text: string;
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                inlineData: {
                    mimeType?: string;
                    data: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                functionCall: {
                    id?: string;
                    name: string;
                    args?: {
                        [key: string]: unknown;
                    };
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                functionResponse: {
                    id?: string;
                    name: string;
                    response: {
                        [key: string]: unknown;
                    };
                    willContinue?: boolean;
                    scheduling?: 'SCHEDULING_UNSPECIFIED' | 'SILENT' | 'WHEN_IDLE' | 'INTERRUPT';
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                fileData: {
                    mimeType?: string;
                    fileUri: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                language: 'LANGUAGE_UNSPECIFIED' | 'PYTHON';
                executableCode: {
                    code: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            } | {
                /**
                 * Indicates if the part is thought from the model
                 */
                thought?: boolean;
                /**
                 * An opaque signature for the thought so it can be reused in subsequent requests. A base64-encoded string
                 */
                thoughtSignature?: string;
                codeExecutionResult: {
                    /**
                     * Outcome of the code execution.
                     */
                    outcome: 'OUTCOME_UNSPECIFIED' | 'OUTCOME_OK' | 'OUTCOME_FAILED' | 'OUTCOME_DEADLINE_EXCEEDED';
                    output?: string;
                };
                /**
                 * https://ai.google.dev/api/caching#VideoMetadata
                 */
                metadata?: {
                    /**
                     * The start offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    startOffset?: string;
                    /**
                     * The end offset of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: '3.5s'
                     */
                    endOffset?: string;
                    /**
                     * The frame rate of the video sent to the model. If not specified, the default value will be 1.0. The fps range is (0.0, 24.0]
                     */
                    fps?: number;
                };
            }>;
        };
        /**
         *
         * The reason why the model stopped generating tokens.
         *
         * If empty, the model has not stopped generating tokens.
         *
         * https://ai.google.dev/api/generate-content#FinishReason
         *
         */
        finishReason?: 'FINISH_REASON_UNSPECIFIED' | 'STOP' | 'MAX_TOKENS' | 'SAFETY' | 'RECITATION' | 'LANGUAGE' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'SPII' | 'MALFORMED_FUNCTION_CALL' | 'IMAGE_SAFETY' | 'IMAGE_PROHIBITED_CONTENT' | 'IMAGE_OTHER' | 'NO_IMAGE' | 'IMAGE_RECITATION' | 'UNEXPECTED_TOOL_CALL' | 'TOO_MANY_TOOL_CALLS';
        safetyRatings?: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked?: boolean;
        }>;
        /**
         * https://ai.google.dev/api/generate-content#citationmetadata
         */
        citationMetadata?: {
            citationSources: Array<{
                startIndex?: number;
                endIndex?: number;
                uri?: string;
                license?: string;
            }>;
        };
        tokenCount?: number;
        groundingAttributions?: Array<unknown>;
        groundingMetadata?: unknown;
        avgLogprobs?: number;
        logprobsResult?: unknown;
        urlContextMetadata?: unknown;
        /**
         * Index of the candidate in the list of response candidates.
         */
        index: number;
        /**
         * Details the reason why the model stopped generating tokens. This is populated only when finishReason is set.
         */
        finishMessage?: string;
    }>;
    /**
     * Returns the prompt's feedback related to the content filters
     */
    promptFeedback?: {
        /**
         * Specifies the reason why the prompt was blocked. https://ai.google.dev/api/generate-content#BlockReason
         */
        blockReason?: 'BLOCK_REASON_UNSPECIFIED' | 'SAFETY' | 'OTHER' | 'BLOCKLIST' | 'PROHIBITED_CONTENT' | 'IMAGE_SAFETY';
        safetyRatings: Array<{
            /**
             *
             * The category for this setting
             *
             * https://ai.google.dev/api/generate-content#v1beta.HarmCategory
             *
             */
            category: 'HARM_CATEGORY_UNSPECIFIED' | 'HARM_CATEGORY_DEROGATORY' | 'HARM_CATEGORY_TOXICITY' | 'HARM_CATEGORY_VIOLENCE' | 'HARM_CATEGORY_SEXUAL' | 'HARM_CATEGORY_MEDICAL' | 'HARM_CATEGORY_DANGEROUS' | 'HARM_CATEGORY_HARASSMENT' | 'HARM_CATEGORY_HATE_SPEECH' | 'HARM_CATEGORY_SEXUALLY_EXPLICIT' | 'HARM_CATEGORY_DANGEROUS_CONTENT' | 'HARM_CATEGORY_CIVIC_INTEGRITY';
            /**
             * https://ai.google.dev/api/generate-content#HarmProbability
             */
            probability: 'HARM_PROBABILITY_UNSPECIFIED' | 'NEGLIGIBLE' | 'LOW' | 'MEDIUM' | 'HIGH';
            /**
             * Was this content blocked because of this rating?
             */
            blocked?: boolean;
        }>;
    };
    /**
     * Metadata on the generation requests' token usage
     */
    usageMetadata?: {
        promptTokenCount?: number;
        cachedContentTokenCount?: number;
        candidatesTokenCount?: number;
        toolUsePromptTokenCount?: number;
        thoughtsTokenCount?: number;
        totalTokenCount?: number;
        promptTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        cacheTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        candidatesTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
        toolUsePromptTokensDetails?: Array<{
            /**
             * https://ai.google.dev/api/generate-content#Modality
             */
            modality: 'MODALITY_UNSPECIFIED' | 'TEXT' | 'IMAGE' | 'AUDIO';
            /**
             * Number of tokens
             */
            tokenCount: number;
        }>;
    };
    /**
     * The model version used to generate the response.
     */
    modelVersion?: string;
    /**
     * The unique response ID.
     */
    responseId?: string;
};

export type AnthropicMessagesRequest = {
    model: string;
    messages: Array<{
        content: string | Array<{
            text: string;
            type: 'text';
            cache_control?: unknown;
            citations?: Array<unknown> | unknown;
        } | {
            type: 'image';
            source: {
                type: 'base64';
                media_type: string;
                data: string;
            };
            cache_control?: unknown;
        } | {
            id: string;
            input: unknown;
            name: string;
            type: 'tool_use';
            cache_control?: unknown;
        } | {
            tool_use_id: string;
            type: 'tool_result';
            cache_control?: unknown;
            content?: string | Array<{
                text: string;
                type: 'text';
                cache_control?: unknown;
                citations?: Array<unknown> | unknown;
            } | {
                type: 'image';
                source: {
                    type: 'base64';
                    media_type: string;
                    data: string;
                };
                cache_control?: unknown;
            }>;
            is_error?: boolean;
        }>;
        role: 'user' | 'assistant';
    }>;
    max_tokens: number;
    container?: string | unknown;
    context_management?: {
        [key: string]: never;
    } | unknown;
    mcp_servers?: Array<unknown>;
    metadata?: {
        user_id: string | unknown;
    };
    service_tier?: unknown;
    stop_sequences?: Array<string>;
    stream?: boolean;
    system?: string | {
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    } | Array<{
        type: 'text';
        text: string;
        cache_control?: unknown;
        citations?: Array<unknown> | unknown;
    }>;
    temperature?: number;
    tool_choice?: {
        type: 'auto';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'any';
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'tool';
        name: string;
        disable_parallel_tool_use?: boolean;
    } | {
        type: 'none';
    };
    tools?: Array<{
        name: string;
        type?: 'custom' | unknown;
        cache_control?: unknown;
        input_schema: {
            [key: string]: unknown;
        };
        description?: string;
    } | {
        name: 'bash';
        type: 'bash_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_editor';
        type: 'text_editor_20250124';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250429';
        cache_control?: unknown;
    } | {
        name: 'str_replace_based_edit_tool';
        type: 'text_editor_20250728';
        cache_control?: unknown;
        max_characters?: number | unknown;
    } | {
        name: 'web_search';
        type: 'web_search_20250305';
        allowed_domains?: Array<string> | unknown;
        blocked_domains?: Array<string> | unknown;
        cache_control?: unknown;
        max_uses?: number | unknown;
        user_location?: unknown;
    }>;
    top_k?: number;
    top_p?: number;
};

export type AnthropicMessagesResponse = {
    id: string;
    content: Array<{
        citations: Array<unknown> | unknown;
        text: string;
        type: 'text';
    } | {
        id: string;
        input: unknown;
        name: string;
        type: 'tool_use';
    }>;
    model: string;
    role: 'assistant';
    stop_reason: unknown;
    stop_sequence: string | unknown;
    type: 'message';
    usage: {
        input_tokens: number;
        output_tokens: number;
    };
};

export type CerebrasChatCompletionRequest = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type CerebrasChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/Cerebras/cerebras-cloud-sdk-node/blob/main/src/resources/chat/completions.ts
         */
        message: {
            content?: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
};

export type CohereChatRequest = {
    model: string;
    messages: Array<{
        role: string;
        content: string | Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
    } | {
        role: string;
        content?: string | Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
        tool_calls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
    } | {
        role: string;
        content: string;
    } | {
        role: string;
        tool_call_id: string;
        content: string;
    }>;
    stream?: boolean;
    temperature?: number;
    max_tokens?: number;
    tools?: Array<{
        type: string;
        function: {
            name: string;
            description?: string;
            parameters?: {
                type: string;
                description?: string;
                required?: Array<string>;
                properties?: {
                    [key: string]: unknown;
                };
            };
        };
    }>;
    tool_choice?: 'REQUIRED' | 'NONE';
    safety_mode?: 'CONTEXTUAL' | 'STRICT' | 'OFF';
    response_format?: {
        type: 'json_object' | 'text';
        json_schema?: {
            [key: string]: unknown;
        };
    };
    frequency_penalty?: number;
    presence_penalty?: number;
    k?: number;
    p?: number;
    seed?: number;
    stop_sequences?: Array<string>;
    logprobs?: boolean;
};

export type CohereChatResponse = {
    id: string;
    message: {
        role: string;
        content?: Array<{
            type: string;
            text: string;
        } | {
            type: string;
            tool_call_id: string;
            content: string;
        }>;
        tool_calls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
    };
    finish_reason: 'COMPLETE' | 'MAX_TOKENS' | 'STOP_SEQUENCE' | 'TOOL_CALL' | 'ERROR';
    usage?: {
        billed_units?: {
            input_tokens?: number;
            output_tokens?: number;
        };
        tokens?: {
            input_tokens?: number;
            output_tokens?: number;
        };
    };
};

export type MistralChatCompletionRequest = {
    model: string;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1186
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L792
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L732
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
         */
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1197
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L765
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     *
     * A function tool that can be used to generate a response.
     *
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1392
     *
     */
    tools?: Array<{
        type: 'function';
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1405
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1455
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model to a pre-defined set.
             *
             * auto allows the model to pick from among the allowed tools and generate a
             * message.
             *
             * required requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            /**
             * A list of tool definitions that the model should be allowed to call
             */
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L174
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                         *
                         * The parameters the functions accepts, described as a JSON Schema object. See the
                         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                         * documentation about the format.
                         *
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool, used to identify it in tool calls
             */
            name: string;
            /**
             * Optional description of the custom tool, used to provide more context
             */
            description?: string;
            /**
             * The input format for the custom tool. Default is unconstrained text.
             */
            format?: {
                /**
                 * Unconstrained text format. Always `text`
                 */
                type: 'text';
            } | {
                type: 'grammar';
                /**
                 * Your chosen grammar
                 */
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar definition
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
};

export type MistralChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    server_tier?: string;
    system_fingerprint?: string | unknown;
    /**
     * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L113
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    };
    [key: string]: unknown | string | Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1000
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            /**
             * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L431
             */
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1165
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * https://github.com/openai/openai-node/blob/v6.0.0/src/resources/chat/completions/completions.ts#L1128
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }> | unknown;
        };
    }> | number | 'chat.completion' | string | unknown | {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L144
         */
        completion_tokens_details?: unknown;
        /**
         * https://github.com/openai/openai-node/blob/master/src/resources/completions.ts#L173
         */
        prompt_tokens_details?: unknown;
    } | undefined;
};

export type VllmChatCompletionRequest = {
    model: string;
    /**
     * A message in the conversation
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * Audio input details
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * File details
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * A tool call in the assistant message
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * Function call details
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * Custom tool call details
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
        reasoning?: string | unknown;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     * A tool definition
     */
    tools?: Array<{
        type: 'function';
        /**
         * A function definition for tool calling
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * The parameters the functions accepts, described as a JSON Schema object.
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * Tool choice option
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * Allowed tools configuration
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model.
             * auto: allows the model to pick from allowed tools or generate a message.
             * required: requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * A function definition for tool calling
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * The parameters the functions accepts, described as a JSON Schema object.
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
    top_p?: number | unknown;
    top_k?: number | unknown;
    frequency_penalty?: number | unknown;
    presence_penalty?: number | unknown;
    repetition_penalty?: number | unknown;
    stop?: string | Array<string>;
    seed?: number | unknown;
    n?: number | unknown;
    best_of?: number | unknown;
    logprobs?: boolean | unknown;
    top_logprobs?: number | unknown;
};

export type VllmChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * The assistant message in the response
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * A tool call in the assistant message
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * Function call details
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * Custom tool call details
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
            reasoning?: string | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * Token usage statistics for the completion
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        completion_tokens_details?: unknown;
        prompt_tokens_details?: unknown;
    };
};

export type OllamaChatCompletionRequest = {
    model: string;
    /**
     * A message in the conversation
     */
    messages: Array<{
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'developer';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        }>;
        role: 'system';
        name?: string;
    } | {
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        } | {
            type: 'input_audio';
            /**
             * Audio input details
             */
            input_audio: {
                data: string;
                format: 'wav' | 'mp3';
            };
        } | {
            type: 'file';
            /**
             * File details
             */
            file: {
                file_data?: string;
                file_id?: string;
                filename?: string;
            };
        }>;
        role: 'user';
        name?: string;
    } | {
        role: 'assistant';
        audio?: {
            id: string;
        } | unknown;
        content?: string | Array<{
            type: 'text';
            text: string;
        }> | Array<{
            type: 'refusal';
            refusal: string;
        }> | unknown;
        function_call?: {
            arguments: string;
            name: string;
        } | unknown;
        name?: string;
        refusal?: string | unknown;
        /**
         * A tool call in the assistant message
         */
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * Function call details
             */
            function: {
                arguments: string;
                name: string;
            };
        } | {
            id: string;
            type: 'custom';
            /**
             * Custom tool call details
             */
            custom: {
                input: string;
                name: string;
            };
        }>;
    } | {
        role: 'tool';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * Image URL details
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string | unknown;
        name: string;
    }>;
    /**
     * A tool definition
     */
    tools?: Array<{
        type: 'function';
        /**
         * A function definition for tool calling
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * The parameters the functions accepts, described as a JSON Schema object.
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    }>;
    /**
     * Tool choice option
     */
    tool_choice?: 'none' | 'auto' | 'required' | {
        type: 'allowed_tools';
        /**
         * Allowed tools configuration
         */
        allowed_tools: {
            /**
             *
             * Constrains the tools available to the model.
             * auto: allows the model to pick from allowed tools or generate a message.
             * required: requires the model to call one or more of the allowed tools.
             *
             */
            mode: 'auto' | 'required';
            tools: Array<{
                [key: string]: {
                    type: 'function';
                    /**
                     * A function definition for tool calling
                     */
                    function: {
                        name: string;
                        description?: string;
                        /**
                         *
                         * The parameters the functions accepts, described as a JSON Schema object.
                         * Omitting parameters defines a function with an empty parameter list.
                         *
                         */
                        parameters?: {
                            [key: string]: unknown;
                        };
                        strict?: boolean | unknown;
                    };
                };
            }>;
        };
    } | {
        type: 'function';
        function: {
            name: string;
        };
    } | {
        type: 'custom';
        custom: {
            /**
             * The name of the custom tool
             */
            name: string;
            /**
             * Description of the tool
             */
            description?: string;
            /**
             * The input format for the custom tool
             */
            format?: {
                /**
                 * Unconstrained text format
                 */
                type: 'text';
            } | {
                type: 'grammar';
                grammar: {
                    /**
                     * The grammar definition
                     */
                    definition: string;
                    /**
                     * The syntax of the grammar
                     */
                    syntax: 'lark' | 'regex';
                };
            };
        };
    };
    temperature?: number | unknown;
    max_tokens?: number | unknown;
    stream?: boolean | unknown;
    top_p?: number | unknown;
    frequency_penalty?: number | unknown;
    presence_penalty?: number | unknown;
    stop?: string | Array<string>;
    seed?: number | unknown;
    n?: number | unknown;
};

export type OllamaChatCompletionResponse = {
    id: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        index: number;
        logprobs: unknown;
        /**
         * The assistant message in the response
         */
        message: {
            content: string | unknown;
            refusal?: string | unknown;
            role: 'assistant';
            annotations?: Array<unknown>;
            audio?: unknown;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
            /**
             * A tool call in the assistant message
             */
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * Function call details
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            } | {
                id: string;
                type: 'custom';
                /**
                 * Custom tool call details
                 */
                custom: {
                    input: string;
                    name: string;
                };
            }>;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * Token usage statistics for the completion
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        completion_tokens_details?: unknown;
        prompt_tokens_details?: unknown;
    };
};

export type ZhipuaiChatCompletionRequest = {
    model: string;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#body
     */
    messages: Array<{
        role: 'system';
        content: string;
        name?: string;
    } | {
        role: 'user';
        content: string | Array<{
            type: 'text';
            text: string;
        } | {
            type: 'image_url';
            /**
             * https://docs.z.ai/api-reference/llm/chat-completion#body
             */
            image_url: {
                url: string;
                detail?: 'auto' | 'low' | 'high';
            };
        }>;
        name?: string;
    } | {
        role: 'assistant';
        content?: string | unknown;
        name?: string;
        tool_calls?: Array<{
            id: string;
            type: 'function';
            /**
             * https://docs.z.ai/api-reference/llm/chat-completion#response
             */
            function: {
                arguments: string;
                name: string;
            };
        }>;
        function_call?: {
            arguments: string;
            name: string;
        };
    } | {
        role: 'tool';
        content: string;
        tool_call_id: string;
    } | {
        role: 'function';
        content: string;
        name: string;
    }>;
    tools?: Array<{
        type: 'function';
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#body
         */
        function: {
            name: string;
            description?: string;
            /**
             *
             * https://docs.z.ai/api-reference/llm/chat-completion#body
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            strict?: boolean | unknown;
        };
    }>;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#body
     */
    tool_choice?: 'auto' | {
        type: 'function';
        function: {
            name: string;
        };
    };
    request_id?: string;
    do_sample?: boolean;
    stream?: boolean;
    thinking?: {
        type: 'enabled' | 'disabled';
        clear_thinking?: boolean;
    };
    temperature?: number | unknown;
    top_p?: number | unknown;
    max_tokens?: number | unknown;
    tool_stream?: boolean;
    stop?: Array<string>;
    response_format?: {
        type: 'text' | 'json_object';
    };
    user_id?: string;
};

export type ZhipuaiChatCompletionResponse = {
    id: string;
    request_id?: string;
    choices: Array<{
        finish_reason: 'stop' | 'length' | 'tool_calls' | 'sensitive' | 'network_error';
        index: number;
        logprobs: unknown;
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#response
         */
        message: {
            content: string | unknown;
            role: 'assistant';
            reasoning_content?: string;
            tool_calls?: Array<{
                id: string;
                type: 'function';
                /**
                 * https://docs.z.ai/api-reference/llm/chat-completion#response
                 */
                function: {
                    arguments: string;
                    name: string;
                };
            }>;
            function_call?: {
                arguments: string;
                name: string;
            } | unknown;
        };
    }>;
    created: number;
    model: string;
    object: 'chat.completion';
    system_fingerprint?: string | unknown;
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#response
     */
    usage?: {
        completion_tokens: number;
        prompt_tokens: number;
        total_tokens: number;
        /**
         * https://docs.z.ai/api-reference/llm/chat-completion#response
         */
        prompt_tokens_details?: {
            cached_tokens: number;
        };
    };
    /**
     * https://docs.z.ai/api-reference/llm/chat-completion#response
     */
    web_search?: Array<{
        title: string;
        content: string;
        link: string;
        media: string;
        icon: string;
        refer: string;
        publish_date: string;
    }>;
};

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type GetHealthResponses = {
    /**
     * Default Response
     */
    200: {
        name: string;
        status: string;
        version: string;
    };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetV1A2aByAgentIdWellKnownAgentJsonData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/a2a/{agentId}/.well-known/agent.json';
};

export type GetV1A2aByAgentIdWellKnownAgentJsonResponses = {
    /**
     * Default Response
     */
    200: {
        name: string;
        description: string;
        url: string;
        version: string;
        capabilities: {
            streaming: boolean;
            pushNotifications: boolean;
            stateTransitionHistory: boolean;
        };
        defaultInputModes: Array<string>;
        defaultOutputModes: Array<string>;
        skills: Array<{
            id: string;
            name: string;
            description: string;
            tags: Array<string>;
            inputModes: Array<string>;
            outputModes: Array<string>;
        }>;
    };
};

export type GetV1A2aByAgentIdWellKnownAgentJsonResponse = GetV1A2aByAgentIdWellKnownAgentJsonResponses[keyof GetV1A2aByAgentIdWellKnownAgentJsonResponses];

export type PostV1A2aByAgentIdData = {
    body: {
        jsonrpc: '2.0';
        id: string | number;
        method: string;
        params?: {
            message?: {
                parts?: Array<{
                    kind: 'text';
                    text: string;
                }>;
            };
        };
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/a2a/{agentId}';
};

export type PostV1A2aByAgentIdResponses = {
    /**
     * Default Response
     */
    200: {
        jsonrpc: '2.0';
        id: string | number;
        result?: {
            messageId: string;
            role: 'user' | 'agent';
            parts: Array<{
                kind: 'text';
                text: string;
            }>;
            contextId?: string;
            taskId?: string;
            metadata?: {
                [key: string]: unknown;
            };
        };
        error?: {
            code: number;
            message: string;
            data?: unknown;
        };
    };
};

export type PostV1A2aByAgentIdResponse = PostV1A2aByAgentIdResponses[keyof PostV1A2aByAgentIdResponses];

export type GetAgentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent name
         */
        name?: string;
        /**
         * Filter by agent type. 'profile' = external API gateway profiles, 'mcp_gateway' = MCP gateway, 'llm_proxy' = LLM proxy, 'agent' = internal agents with prompts.
         */
        agentType?: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        /**
         * Filter by multiple agent types (comma-separated). Takes precedence over agentType if both provided.
         */
        agentTypes?: Array<'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent'>;
        limit?: number;
        offset?: number;
        sortBy?: 'name' | 'createdAt' | 'toolsCount' | 'team';
        sortDirection?: 'asc' | 'desc';
    };
    url: '/api/agents';
};

export type GetAgentsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentsError = GetAgentsErrors[keyof GetAgentsErrors];

export type GetAgentsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            organizationId: string;
            name: string;
            isDemo: boolean;
            isDefault: boolean;
            considerContextUntrusted: boolean;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            systemPrompt: string | null;
            userPrompt: string | null;
            promptVersion: number | null;
            promptHistory: string | number | boolean | null | {
                [key: string]: unknown;
            } | Array<unknown> | null;
            allowedChatops: string | number | boolean | null | {
                [key: string]: unknown;
            } | Array<unknown> | null;
            description: string | null;
            incomingEmailEnabled: boolean;
            incomingEmailSecurityMode: 'private' | 'internal' | 'public';
            incomingEmailAllowedDomain: string | null;
            llmApiKeyId: string | null;
            llmModel: string | null;
            identityProviderId: string | null;
            createdAt: string;
            updatedAt: string;
            tools: Array<{
                id: string;
                agentId: string | null;
                catalogId: string | null;
                mcpServerId: string | null;
                delegateToAgentId: string | null;
                name: string;
                /**
                 *
                 * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                 *
                 * The parameters the functions accepts, described as a JSON Schema object. See the
                 * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                 * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                 * documentation about the format.
                 *
                 * Omitting parameters defines a function with an empty parameter list.
                 *
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                description: string | null;
                policiesAutoConfiguredAt: string | null;
                policiesAutoConfiguringStartedAt: string | null;
                policiesAutoConfiguredReasoning: string | null;
                createdAt: string;
                updatedAt: string;
            }>;
            teams: Array<{
                id: string;
                name: string;
            }>;
            labels: Array<{
                key: string;
                value: string;
                keyId?: string;
                valueId?: string;
            }>;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetAgentsResponse = GetAgentsResponses[keyof GetAgentsResponses];

export type CreateAgentData = {
    body: {
        organizationId?: string;
        name: string;
        isDemo?: boolean;
        isDefault?: boolean;
        considerContextUntrusted?: boolean;
        agentType?: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt?: string | null;
        userPrompt?: string | null;
        allowedChatops?: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description?: string | null;
        incomingEmailEnabled?: boolean;
        incomingEmailSecurityMode?: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain?: string | null;
        llmApiKeyId?: string | null;
        llmModel?: string | null;
        identityProviderId?: string | null;
        teams: Array<string>;
        labels?: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
    path?: never;
    query?: never;
    url: '/api/agents';
};

export type CreateAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateAgentError = CreateAgentErrors[keyof CreateAgentErrors];

export type CreateAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type CreateAgentResponse = CreateAgentResponses[keyof CreateAgentResponses];

export type GetAllAgentsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent type. 'profile' = external API gateway profiles, 'mcp_gateway' = MCP gateway, 'llm_proxy' = LLM proxy, 'agent' = internal agents with prompts.
         */
        agentType?: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        /**
         * Filter by multiple agent types (comma-separated). Takes precedence over agentType if both provided.
         */
        agentTypes?: Array<'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent'>;
    };
    url: '/api/agents/all';
};

export type GetAllAgentsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAllAgentsError = GetAllAgentsErrors[keyof GetAllAgentsErrors];

export type GetAllAgentsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    }>;
};

export type GetAllAgentsResponse = GetAllAgentsResponses[keyof GetAllAgentsResponses];

export type GetDefaultMcpGatewayData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/mcp-gateways/default';
};

export type GetDefaultMcpGatewayErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDefaultMcpGatewayError = GetDefaultMcpGatewayErrors[keyof GetDefaultMcpGatewayErrors];

export type GetDefaultMcpGatewayResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type GetDefaultMcpGatewayResponse = GetDefaultMcpGatewayResponses[keyof GetDefaultMcpGatewayResponses];

export type GetDefaultLlmProxyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/llm-proxy/default';
};

export type GetDefaultLlmProxyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDefaultLlmProxyError = GetDefaultLlmProxyErrors[keyof GetDefaultLlmProxyErrors];

export type GetDefaultLlmProxyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type GetDefaultLlmProxyResponse = GetDefaultLlmProxyResponses[keyof GetDefaultLlmProxyResponses];

export type DeleteAgentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type DeleteAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteAgentError = DeleteAgentErrors[keyof DeleteAgentErrors];

export type DeleteAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteAgentResponse = DeleteAgentResponses[keyof DeleteAgentResponses];

export type GetAgentData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type GetAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentError = GetAgentErrors[keyof GetAgentErrors];

export type GetAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type GetAgentResponse = GetAgentResponses[keyof GetAgentResponses];

export type UpdateAgentData = {
    body?: {
        organizationId?: string;
        name?: string;
        isDemo?: boolean;
        isDefault?: boolean;
        considerContextUntrusted?: boolean;
        agentType?: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt?: string | null;
        userPrompt?: string | null;
        allowedChatops?: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description?: string | null;
        incomingEmailEnabled?: boolean;
        incomingEmailSecurityMode?: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain?: string | null;
        llmApiKeyId?: string | null;
        llmModel?: string | null;
        identityProviderId?: string | null;
        teams?: Array<string>;
        labels?: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}';
};

export type UpdateAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateAgentError = UpdateAgentErrors[keyof UpdateAgentErrors];

export type UpdateAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type UpdateAgentResponse = UpdateAgentResponses[keyof UpdateAgentResponses];

export type GetAgentVersionsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}/versions';
};

export type GetAgentVersionsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentVersionsError = GetAgentVersionsErrors[keyof GetAgentVersionsErrors];

export type GetAgentVersionsResponses = {
    /**
     * Default Response
     */
    200: {
        current: {
            id: string;
            organizationId: string;
            name: string;
            isDemo: boolean;
            isDefault: boolean;
            considerContextUntrusted: boolean;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            systemPrompt: string | null;
            userPrompt: string | null;
            promptVersion: number | null;
            promptHistory: string | number | boolean | null | {
                [key: string]: unknown;
            } | Array<unknown> | null;
            allowedChatops: string | number | boolean | null | {
                [key: string]: unknown;
            } | Array<unknown> | null;
            description: string | null;
            incomingEmailEnabled: boolean;
            incomingEmailSecurityMode: 'private' | 'internal' | 'public';
            incomingEmailAllowedDomain: string | null;
            llmApiKeyId: string | null;
            llmModel: string | null;
            identityProviderId: string | null;
            createdAt: string;
            updatedAt: string;
            tools: Array<{
                id: string;
                agentId: string | null;
                catalogId: string | null;
                mcpServerId: string | null;
                delegateToAgentId: string | null;
                name: string;
                /**
                 *
                 * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                 *
                 * The parameters the functions accepts, described as a JSON Schema object. See the
                 * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                 * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                 * documentation about the format.
                 *
                 * Omitting parameters defines a function with an empty parameter list.
                 *
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                description: string | null;
                policiesAutoConfiguredAt: string | null;
                policiesAutoConfiguringStartedAt: string | null;
                policiesAutoConfiguredReasoning: string | null;
                createdAt: string;
                updatedAt: string;
            }>;
            teams: Array<{
                id: string;
                name: string;
            }>;
            labels: Array<{
                key: string;
                value: string;
                keyId?: string;
                valueId?: string;
            }>;
        };
        history: Array<{
            version: number;
            userPrompt: string | null;
            systemPrompt: string | null;
            createdAt: string;
        }>;
    };
};

export type GetAgentVersionsResponse = GetAgentVersionsResponses[keyof GetAgentVersionsResponses];

export type RollbackAgentData = {
    body: {
        /**
         * Version to rollback to
         */
        version: number;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agents/{id}/rollback';
};

export type RollbackAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RollbackAgentError = RollbackAgentErrors[keyof RollbackAgentErrors];

export type RollbackAgentResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        isDemo: boolean;
        isDefault: boolean;
        considerContextUntrusted: boolean;
        agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        systemPrompt: string | null;
        userPrompt: string | null;
        promptVersion: number | null;
        promptHistory: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        allowedChatops: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        description: string | null;
        incomingEmailEnabled: boolean;
        incomingEmailSecurityMode: 'private' | 'internal' | 'public';
        incomingEmailAllowedDomain: string | null;
        llmApiKeyId: string | null;
        llmModel: string | null;
        identityProviderId: string | null;
        createdAt: string;
        updatedAt: string;
        tools: Array<{
            id: string;
            agentId: string | null;
            catalogId: string | null;
            mcpServerId: string | null;
            delegateToAgentId: string | null;
            name: string;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            description: string | null;
            policiesAutoConfiguredAt: string | null;
            policiesAutoConfiguringStartedAt: string | null;
            policiesAutoConfiguredReasoning: string | null;
            createdAt: string;
            updatedAt: string;
        }>;
        teams: Array<{
            id: string;
            name: string;
        }>;
        labels: Array<{
            key: string;
            value: string;
            keyId?: string;
            valueId?: string;
        }>;
    };
};

export type RollbackAgentResponse = RollbackAgentResponses[keyof RollbackAgentResponses];

export type GetLabelKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/agents/labels/keys';
};

export type GetLabelKeysErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetLabelKeysError = GetLabelKeysErrors[keyof GetLabelKeysErrors];

export type GetLabelKeysResponses = {
    /**
     * Default Response
     */
    200: Array<string>;
};

export type GetLabelKeysResponse = GetLabelKeysResponses[keyof GetLabelKeysResponses];

export type GetLabelValuesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter values by label key
         */
        key?: string;
    };
    url: '/api/agents/labels/values';
};

export type GetLabelValuesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetLabelValuesError = GetLabelValuesErrors[keyof GetLabelValuesErrors];

export type GetLabelValuesResponses = {
    /**
     * Default Response
     */
    200: Array<string>;
};

export type GetLabelValuesResponse = GetLabelValuesResponses[keyof GetLabelValuesResponses];

export type GetAllAgentToolsData = {
    body?: never;
    path?: never;
    query?: {
        search?: string;
        agentId?: string;
        /**
         * Can be 'llm-proxy' or a catalogId
         */
        origin?: string;
        /**
         * Filter by MCP server owner user ID
         */
        mcpServerOwnerId?: string;
        /**
         * For test isolation
         */
        excludeArchestraTools?: boolean;
        sortBy?: 'name' | 'agent' | 'origin' | 'createdAt';
        sortDirection?: 'asc' | 'desc';
        skipPagination?: boolean;
        limit?: number;
        offset?: number;
    };
    url: '/api/agent-tools';
};

export type GetAllAgentToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAllAgentToolsError = GetAllAgentToolsErrors[keyof GetAllAgentToolsErrors];

export type GetAllAgentToolsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            responseModifierTemplate: string | null;
            credentialSourceMcpServerId: string | null;
            executionSourceMcpServerId: string | null;
            useDynamicTeamCredential: boolean;
            createdAt: string;
            updatedAt: string;
            agent: {
                id: string;
                name: string;
            };
            tool: {
                id: string;
                name: string;
                description: string | null;
                /**
                 *
                 * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
                 *
                 * The parameters the functions accepts, described as a JSON Schema object. See the
                 * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
                 * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
                 * documentation about the format.
                 *
                 * Omitting parameters defines a function with an empty parameter list.
                 *
                 */
                parameters?: {
                    [key: string]: unknown;
                };
                createdAt: string;
                updatedAt: string;
                catalogId: string | null;
                mcpServerId: string | null;
                mcpServerName: string | null;
                mcpServerCatalogId: string | null;
            };
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetAllAgentToolsResponse = GetAllAgentToolsResponses[keyof GetAllAgentToolsResponses];

export type UnassignToolFromAgentData = {
    body?: never;
    path: {
        agentId: string;
        toolId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/tools/{toolId}';
};

export type UnassignToolFromAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UnassignToolFromAgentError = UnassignToolFromAgentErrors[keyof UnassignToolFromAgentErrors];

export type UnassignToolFromAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type UnassignToolFromAgentResponse = UnassignToolFromAgentResponses[keyof UnassignToolFromAgentResponses];

export type AssignToolToAgentData = {
    body?: {
        credentialSourceMcpServerId?: string | null;
        executionSourceMcpServerId?: string | null;
        useDynamicTeamCredential?: boolean;
    } | null;
    path: {
        agentId: string;
        toolId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/tools/{toolId}';
};

export type AssignToolToAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AssignToolToAgentError = AssignToolToAgentErrors[keyof AssignToolToAgentErrors];

export type AssignToolToAgentResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type AssignToolToAgentResponse = AssignToolToAgentResponses[keyof AssignToolToAgentResponses];

export type BulkAssignToolsData = {
    body: {
        assignments: Array<{
            agentId: string;
            toolId: string;
            credentialSourceMcpServerId?: string | null;
            executionSourceMcpServerId?: string | null;
            useDynamicTeamCredential?: boolean;
        }>;
    };
    path?: never;
    query?: never;
    url: '/api/agents/tools/bulk-assign';
};

export type BulkAssignToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BulkAssignToolsError = BulkAssignToolsErrors[keyof BulkAssignToolsErrors];

export type BulkAssignToolsResponses = {
    /**
     * Default Response
     */
    200: {
        succeeded: Array<{
            agentId: string;
            toolId: string;
        }>;
        failed: Array<{
            agentId: string;
            toolId: string;
            error: string;
        }>;
        duplicates: Array<{
            agentId: string;
            toolId: string;
        }>;
    };
};

export type BulkAssignToolsResponse = BulkAssignToolsResponses[keyof BulkAssignToolsResponses];

export type AutoConfigureAgentToolPoliciesData = {
    body: {
        toolIds: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/api/agent-tools/auto-configure-policies';
};

export type AutoConfigureAgentToolPoliciesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AutoConfigureAgentToolPoliciesError = AutoConfigureAgentToolPoliciesErrors[keyof AutoConfigureAgentToolPoliciesErrors];

export type AutoConfigureAgentToolPoliciesResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
        results: Array<{
            toolId: string;
            success: boolean;
            config?: {
                toolInvocationAction: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
                trustedDataAction: 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm' | 'block_always';
                reasoning: string;
            };
            error?: string;
        }>;
    };
};

export type AutoConfigureAgentToolPoliciesResponse = AutoConfigureAgentToolPoliciesResponses[keyof AutoConfigureAgentToolPoliciesResponses];

export type GetAgentToolsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: {
        excludeLlmProxyOrigin?: boolean;
    };
    url: '/api/agents/{agentId}/tools';
};

export type GetAgentToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentToolsError = GetAgentToolsErrors[keyof GetAgentToolsErrors];

export type GetAgentToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentId: string | null;
        catalogId: string | null;
        mcpServerId: string | null;
        delegateToAgentId: string | null;
        name: string;
        /**
         *
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
         *
         * The parameters the functions accepts, described as a JSON Schema object. See the
         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
         * documentation about the format.
         *
         * Omitting parameters defines a function with an empty parameter list.
         *
         */
        parameters?: {
            [key: string]: unknown;
        };
        description: string | null;
        policiesAutoConfiguredAt: string | null;
        policiesAutoConfiguringStartedAt: string | null;
        policiesAutoConfiguredReasoning: string | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetAgentToolsResponse = GetAgentToolsResponses[keyof GetAgentToolsResponses];

export type UpdateAgentToolData = {
    body?: {
        responseModifierTemplate?: string | null;
        credentialSourceMcpServerId?: string | null;
        executionSourceMcpServerId?: string | null;
        useDynamicTeamCredential?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/agent-tools/{id}';
};

export type UpdateAgentToolErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateAgentToolError = UpdateAgentToolErrors[keyof UpdateAgentToolErrors];

export type UpdateAgentToolResponses = {
    /**
     * Default Response
     */
    200: {
        id?: string;
        agentId?: string;
        toolId?: string;
        responseModifierTemplate?: string | null;
        credentialSourceMcpServerId?: string | null;
        executionSourceMcpServerId?: string | null;
        useDynamicTeamCredential?: boolean;
        createdAt?: string;
        updatedAt?: string;
    };
};

export type UpdateAgentToolResponse = UpdateAgentToolResponses[keyof UpdateAgentToolResponses];

export type GetAgentDelegationsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/delegations';
};

export type GetAgentDelegationsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentDelegationsError = GetAgentDelegationsErrors[keyof GetAgentDelegationsErrors];

export type GetAgentDelegationsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        description: string | null;
        systemPrompt: string | null;
    }>;
};

export type GetAgentDelegationsResponse = GetAgentDelegationsResponses[keyof GetAgentDelegationsResponses];

export type SyncAgentDelegationsData = {
    body: {
        targetAgentIds: Array<string>;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/delegations';
};

export type SyncAgentDelegationsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type SyncAgentDelegationsError = SyncAgentDelegationsErrors[keyof SyncAgentDelegationsErrors];

export type SyncAgentDelegationsResponses = {
    /**
     * Default Response
     */
    200: {
        added: Array<string>;
        removed: Array<string>;
    };
};

export type SyncAgentDelegationsResponse = SyncAgentDelegationsResponses[keyof SyncAgentDelegationsResponses];

export type DeleteAgentDelegationData = {
    body?: never;
    path: {
        agentId: string;
        targetAgentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/delegations/{targetAgentId}';
};

export type DeleteAgentDelegationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteAgentDelegationError = DeleteAgentDelegationErrors[keyof DeleteAgentDelegationErrors];

export type DeleteAgentDelegationResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteAgentDelegationResponse = DeleteAgentDelegationResponses[keyof DeleteAgentDelegationResponses];

export type GetAllDelegationConnectionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/agent-delegations';
};

export type GetAllDelegationConnectionsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAllDelegationConnectionsError = GetAllDelegationConnectionsErrors[keyof GetAllDelegationConnectionsErrors];

export type GetAllDelegationConnectionsResponses = {
    /**
     * Default Response
     */
    200: {
        connections: Array<{
            sourceAgentId: string;
            sourceAgentName: string;
            targetAgentId: string;
            targetAgentName: string;
            toolId: string;
        }>;
        agents: Array<{
            id: string;
            name: string;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
        }>;
    };
};

export type GetAllDelegationConnectionsResponse = GetAllDelegationConnectionsResponses[keyof GetAllDelegationConnectionsResponses];

export type AnthropicMessagesWithDefaultAgentData = {
    body?: AnthropicMessagesRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        'anthropic-version': string;
        /**
         * Beta features to enable (comma-separated)
         */
        'anthropic-beta'?: string;
        'x-api-key'?: string;
        /**
         * Authorization header (Bearer token for OAuth)
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/anthropic/v1/messages';
};

export type AnthropicMessagesWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AnthropicMessagesWithDefaultAgentError = AnthropicMessagesWithDefaultAgentErrors[keyof AnthropicMessagesWithDefaultAgentErrors];

export type AnthropicMessagesWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: AnthropicMessagesResponse;
};

export type AnthropicMessagesWithDefaultAgentResponse = AnthropicMessagesWithDefaultAgentResponses[keyof AnthropicMessagesWithDefaultAgentResponses];

export type AnthropicMessagesWithAgentData = {
    body?: AnthropicMessagesRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        'anthropic-version': string;
        /**
         * Beta features to enable (comma-separated)
         */
        'anthropic-beta'?: string;
        'x-api-key'?: string;
        /**
         * Authorization header (Bearer token for OAuth)
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/anthropic/{agentId}/v1/messages';
};

export type AnthropicMessagesWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AnthropicMessagesWithAgentError = AnthropicMessagesWithAgentErrors[keyof AnthropicMessagesWithAgentErrors];

export type AnthropicMessagesWithAgentResponses = {
    /**
     * Default Response
     */
    200: AnthropicMessagesResponse;
};

export type AnthropicMessagesWithAgentResponse = AnthropicMessagesWithAgentResponses[keyof AnthropicMessagesWithAgentResponses];

export type GetDefaultCredentialsStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/default-credentials-status';
};

export type GetDefaultCredentialsStatusErrors = {
    /**
     * Default Response
     */
    500: {
        enabled: boolean;
    };
};

export type GetDefaultCredentialsStatusError = GetDefaultCredentialsStatusErrors[keyof GetDefaultCredentialsStatusErrors];

export type GetDefaultCredentialsStatusResponses = {
    /**
     * Default Response
     */
    200: {
        enabled: boolean;
    };
};

export type GetDefaultCredentialsStatusResponse = GetDefaultCredentialsStatusResponses[keyof GetDefaultCredentialsStatusResponses];

export type PostApiAuthOrganizationRemoveMemberData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/organization/remove-member';
};

export type PostApiAuthOrganizationRemoveMemberResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetOAuthClientInfoData = {
    body?: never;
    path?: never;
    query: {
        client_id: string;
    };
    url: '/api/auth/oauth2/client-info';
};

export type GetOAuthClientInfoResponses = {
    /**
     * Default Response
     */
    200: {
        client_name: string | null;
    };
};

export type GetOAuthClientInfoResponse = GetOAuthClientInfoResponses[keyof GetOAuthClientInfoResponses];

export type GetApiAuthOauth2AuthorizeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/authorize';
};

export type GetApiAuthOauth2AuthorizeResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostApiAuthOauth2TokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/token';
};

export type PostApiAuthOauth2TokenResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type SubmitOAuthConsentData = {
    body: {
        accept: boolean;
        scope: string;
        oauth_query: string;
    };
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/consent';
};

export type SubmitOAuthConsentResponses = {
    /**
     * Default Response
     */
    200: {
        redirectTo: string;
    };
};

export type SubmitOAuthConsentResponse = SubmitOAuthConsentResponses[keyof SubmitOAuthConsentResponses];

export type PostApiAuthOauth2RegisterData = {
    body?: {
        [key: string]: unknown;
    };
    path?: never;
    query?: never;
    url: '/api/auth/oauth2/register';
};

export type PostApiAuthOauth2RegisterResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetApiAuthBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/api/auth/{*}';
};

export type GetApiAuthBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type PostApiAuthBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/api/auth/{*}';
};

export type PostApiAuthBy__Responses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetOperatorsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/operators';
};

export type GetOperatorsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetOperatorsError = GetOperatorsErrors[keyof GetOperatorsErrors];

export type GetOperatorsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        value: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
        label: string;
    }>;
};

export type GetOperatorsResponse = GetOperatorsResponses[keyof GetOperatorsResponses];

export type GetToolInvocationPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/tool-invocation';
};

export type GetToolInvocationPoliciesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetToolInvocationPoliciesError = GetToolInvocationPoliciesErrors[keyof GetToolInvocationPoliciesErrors];

export type GetToolInvocationPoliciesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        toolId: string;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetToolInvocationPoliciesResponse = GetToolInvocationPoliciesResponses[keyof GetToolInvocationPoliciesResponses];

export type CreateToolInvocationPolicyData = {
    body: {
        toolId: string;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason?: string | null;
    };
    path?: never;
    query?: never;
    url: '/api/autonomy-policies/tool-invocation';
};

export type CreateToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateToolInvocationPolicyError = CreateToolInvocationPolicyErrors[keyof CreateToolInvocationPolicyErrors];

export type CreateToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateToolInvocationPolicyResponse = CreateToolInvocationPolicyResponses[keyof CreateToolInvocationPolicyResponses];

export type DeleteToolInvocationPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type DeleteToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteToolInvocationPolicyError = DeleteToolInvocationPolicyErrors[keyof DeleteToolInvocationPolicyErrors];

export type DeleteToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteToolInvocationPolicyResponse = DeleteToolInvocationPolicyResponses[keyof DeleteToolInvocationPolicyResponses];

export type GetToolInvocationPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type GetToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetToolInvocationPolicyError = GetToolInvocationPolicyErrors[keyof GetToolInvocationPolicyErrors];

export type GetToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetToolInvocationPolicyResponse = GetToolInvocationPolicyResponses[keyof GetToolInvocationPolicyResponses];

export type UpdateToolInvocationPolicyData = {
    body?: {
        toolId?: string;
        conditions?: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action?: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason?: string | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/autonomy-policies/tool-invocation/{id}';
};

export type UpdateToolInvocationPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateToolInvocationPolicyError = UpdateToolInvocationPolicyErrors[keyof UpdateToolInvocationPolicyErrors];

export type UpdateToolInvocationPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
        reason: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateToolInvocationPolicyResponse = UpdateToolInvocationPolicyResponses[keyof UpdateToolInvocationPolicyResponses];

export type GetTrustedDataPoliciesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/trusted-data-policies';
};

export type GetTrustedDataPoliciesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTrustedDataPoliciesError = GetTrustedDataPoliciesErrors[keyof GetTrustedDataPoliciesErrors];

export type GetTrustedDataPoliciesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        toolId: string;
        description: string | null;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetTrustedDataPoliciesResponse = GetTrustedDataPoliciesResponses[keyof GetTrustedDataPoliciesResponses];

export type CreateTrustedDataPolicyData = {
    body: {
        toolId: string;
        description?: string | null;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
    };
    path?: never;
    query?: never;
    url: '/api/trusted-data-policies';
};

export type CreateTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateTrustedDataPolicyError = CreateTrustedDataPolicyErrors[keyof CreateTrustedDataPolicyErrors];

export type CreateTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        description: string | null;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateTrustedDataPolicyResponse = CreateTrustedDataPolicyResponses[keyof CreateTrustedDataPolicyResponses];

export type DeleteTrustedDataPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type DeleteTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteTrustedDataPolicyError = DeleteTrustedDataPolicyErrors[keyof DeleteTrustedDataPolicyErrors];

export type DeleteTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteTrustedDataPolicyResponse = DeleteTrustedDataPolicyResponses[keyof DeleteTrustedDataPolicyResponses];

export type GetTrustedDataPolicyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type GetTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTrustedDataPolicyError = GetTrustedDataPolicyErrors[keyof GetTrustedDataPolicyErrors];

export type GetTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        description: string | null;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type GetTrustedDataPolicyResponse = GetTrustedDataPolicyResponses[keyof GetTrustedDataPolicyResponses];

export type UpdateTrustedDataPolicyData = {
    body?: {
        toolId?: string;
        description?: string | null;
        conditions?: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action?: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/trusted-data-policies/{id}';
};

export type UpdateTrustedDataPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateTrustedDataPolicyError = UpdateTrustedDataPolicyErrors[keyof UpdateTrustedDataPolicyErrors];

export type UpdateTrustedDataPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        toolId: string;
        description: string | null;
        conditions: Array<{
            key: string;
            operator: 'equal' | 'notEqual' | 'contains' | 'notContains' | 'startsWith' | 'endsWith' | 'regex';
            value: string;
        }>;
        action: 'block_always' | 'mark_as_trusted' | 'mark_as_untrusted' | 'sanitize_with_dual_llm';
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateTrustedDataPolicyResponse = UpdateTrustedDataPolicyResponses[keyof UpdateTrustedDataPolicyResponses];

export type BulkUpsertDefaultCallPolicyData = {
    body: {
        toolIds: Array<string>;
        action: 'allow_when_context_is_untrusted' | 'block_when_context_is_untrusted' | 'block_always';
    };
    path?: never;
    query?: never;
    url: '/api/tool-invocation/bulk-default';
};

export type BulkUpsertDefaultCallPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BulkUpsertDefaultCallPolicyError = BulkUpsertDefaultCallPolicyErrors[keyof BulkUpsertDefaultCallPolicyErrors];

export type BulkUpsertDefaultCallPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        updated: number;
        created: number;
    };
};

export type BulkUpsertDefaultCallPolicyResponse = BulkUpsertDefaultCallPolicyResponses[keyof BulkUpsertDefaultCallPolicyResponses];

export type BulkUpsertDefaultResultPolicyData = {
    body: {
        toolIds: Array<string>;
        action: 'mark_as_trusted' | 'mark_as_untrusted' | 'block_always' | 'sanitize_with_dual_llm';
    };
    path?: never;
    query?: never;
    url: '/api/trusted-data-policies/bulk-default';
};

export type BulkUpsertDefaultResultPolicyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BulkUpsertDefaultResultPolicyError = BulkUpsertDefaultResultPolicyErrors[keyof BulkUpsertDefaultResultPolicyErrors];

export type BulkUpsertDefaultResultPolicyResponses = {
    /**
     * Default Response
     */
    200: {
        updated: number;
        created: number;
    };
};

export type BulkUpsertDefaultResultPolicyResponse = BulkUpsertDefaultResultPolicyResponses[keyof BulkUpsertDefaultResultPolicyResponses];

export type BedrockConverseWithDefaultAgentData = {
    body: {
        modelId: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/bedrock/converse';
};

export type BedrockConverseWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BedrockConverseWithDefaultAgentError = BedrockConverseWithDefaultAgentErrors[keyof BedrockConverseWithDefaultAgentErrors];

export type BedrockConverseWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: {
        $metadata?: {
            httpStatusCode?: number;
            requestId?: string;
            attempts?: number;
            totalRetryDelay?: number;
        };
        output: {
            message?: {
                role: 'assistant';
                content: Array<{
                    text: string;
                } | {
                    toolUse: {
                        toolUseId: string;
                        name: string;
                        input: {
                            [key: string]: unknown;
                        };
                    };
                }>;
            };
        };
        stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | 'model_context_window_exceeded';
        usage: {
            inputTokens: number;
            outputTokens: number;
            totalTokens?: number;
            cacheReadInputTokens?: number;
            cacheWriteInputTokens?: number;
        };
        metrics?: {
            latencyMs?: number;
        };
        additionalModelResponseFields?: {
            [key: string]: unknown;
        };
        trace?: {
            guardrail?: {
                inputAssessment?: {
                    [key: string]: unknown;
                };
                outputAssessments?: {
                    [key: string]: unknown;
                };
                modelOutput?: Array<string>;
                actionReason?: string;
            };
            promptRouter?: {
                invokedModelId?: string;
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
    };
};

export type BedrockConverseWithDefaultAgentResponse = BedrockConverseWithDefaultAgentResponses[keyof BedrockConverseWithDefaultAgentResponses];

export type BedrockConverseWithAgentData = {
    body: {
        modelId: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/bedrock/{agentId}/converse';
};

export type BedrockConverseWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BedrockConverseWithAgentError = BedrockConverseWithAgentErrors[keyof BedrockConverseWithAgentErrors];

export type BedrockConverseWithAgentResponses = {
    /**
     * Default Response
     */
    200: {
        $metadata?: {
            httpStatusCode?: number;
            requestId?: string;
            attempts?: number;
            totalRetryDelay?: number;
        };
        output: {
            message?: {
                role: 'assistant';
                content: Array<{
                    text: string;
                } | {
                    toolUse: {
                        toolUseId: string;
                        name: string;
                        input: {
                            [key: string]: unknown;
                        };
                    };
                }>;
            };
        };
        stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | 'model_context_window_exceeded';
        usage: {
            inputTokens: number;
            outputTokens: number;
            totalTokens?: number;
            cacheReadInputTokens?: number;
            cacheWriteInputTokens?: number;
        };
        metrics?: {
            latencyMs?: number;
        };
        additionalModelResponseFields?: {
            [key: string]: unknown;
        };
        trace?: {
            guardrail?: {
                inputAssessment?: {
                    [key: string]: unknown;
                };
                outputAssessments?: {
                    [key: string]: unknown;
                };
                modelOutput?: Array<string>;
                actionReason?: string;
            };
            promptRouter?: {
                invokedModelId?: string;
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
    };
};

export type BedrockConverseWithAgentResponse = BedrockConverseWithAgentResponses[keyof BedrockConverseWithAgentResponses];

export type BedrockConverseStreamWithDefaultAgentData = {
    body: {
        modelId: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/bedrock/converse-stream';
};

export type BedrockConverseStreamWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type BedrockConverseStreamWithAgentData = {
    body: {
        modelId: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/bedrock/{agentId}/converse-stream';
};

export type BedrockConverseStreamWithAgentResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type BedrockConverseWithAgentAndModelData = {
    body?: {
        modelId?: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path: {
        agentId: string;
        modelId: string;
    };
    query?: never;
    url: '/v1/bedrock/{agentId}/model/{modelId}/converse';
};

export type BedrockConverseWithAgentAndModelErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type BedrockConverseWithAgentAndModelError = BedrockConverseWithAgentAndModelErrors[keyof BedrockConverseWithAgentAndModelErrors];

export type BedrockConverseWithAgentAndModelResponses = {
    /**
     * Default Response
     */
    200: {
        $metadata?: {
            httpStatusCode?: number;
            requestId?: string;
            attempts?: number;
            totalRetryDelay?: number;
        };
        output: {
            message?: {
                role: 'assistant';
                content: Array<{
                    text: string;
                } | {
                    toolUse: {
                        toolUseId: string;
                        name: string;
                        input: {
                            [key: string]: unknown;
                        };
                    };
                }>;
            };
        };
        stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | 'model_context_window_exceeded';
        usage: {
            inputTokens: number;
            outputTokens: number;
            totalTokens?: number;
            cacheReadInputTokens?: number;
            cacheWriteInputTokens?: number;
        };
        metrics?: {
            latencyMs?: number;
        };
        additionalModelResponseFields?: {
            [key: string]: unknown;
        };
        trace?: {
            guardrail?: {
                inputAssessment?: {
                    [key: string]: unknown;
                };
                outputAssessments?: {
                    [key: string]: unknown;
                };
                modelOutput?: Array<string>;
                actionReason?: string;
            };
            promptRouter?: {
                invokedModelId?: string;
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
    };
};

export type BedrockConverseWithAgentAndModelResponse = BedrockConverseWithAgentAndModelResponses[keyof BedrockConverseWithAgentAndModelResponses];

export type BedrockConverseStreamWithAgentAndModelData = {
    body?: {
        modelId?: string;
        messages?: Array<{
            role: 'user' | 'assistant';
            content: Array<{
                text: string;
            } | {
                image: {
                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                document: {
                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                    name: string;
                    source: {
                        bytes: string;
                    } | {
                        s3Location: {
                            uri: string;
                            bucketOwner?: string;
                        };
                    };
                };
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            } | {
                toolUse: {
                    toolUseId: string;
                    name: string;
                    input: {
                        [key: string]: unknown;
                    };
                };
            } | {
                toolResult: {
                    toolUseId: string;
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    }>;
                    status?: 'success' | 'error';
                };
            }>;
        }>;
        system?: Array<{
            text: string;
        } | {
            guardContent: {
                text: {
                    text: string;
                    qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                };
            };
        }>;
        inferenceConfig?: {
            maxTokens?: number;
            temperature?: number;
            topP?: number;
            stopSequences?: Array<string>;
        };
        toolConfig?: {
            tools: Array<{
                toolSpec: {
                    name: string;
                    description?: string;
                    inputSchema: {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
            }>;
            toolChoice?: {
                auto?: {
                    [key: string]: unknown;
                };
            } | {
                any?: {
                    [key: string]: unknown;
                };
            } | {
                tool: {
                    name: string;
                };
            };
        };
        guardrailConfig?: {
            guardrailIdentifier: string;
            guardrailVersion: string;
            trace?: 'enabled' | 'disabled';
        };
        additionalModelRequestFields?: {
            [key: string]: unknown;
        };
        additionalModelResponseFieldPaths?: Array<string>;
        promptVariables?: {
            [key: string]: {
                text: string;
            } | {
                json: {
                    [key: string]: unknown;
                };
            };
        };
        performanceConfig?: {
            latency?: 'optimized';
        };
        serviceTier?: {
            type?: 'default' | 'throughput';
        };
        requestMetadata?: {
            [key: string]: string;
        };
        _isStreaming?: boolean;
    };
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Authorization header with Bearer token
         */
        authorization?: string;
    };
    path: {
        agentId: string;
        modelId: string;
    };
    query?: never;
    url: '/v1/bedrock/{agentId}/model/{modelId}/converse-stream';
};

export type BedrockConverseStreamWithAgentAndModelResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type CerebrasChatCompletionsWithDefaultAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v1/cerebras/chat/completions';
};

export type CerebrasChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CerebrasChatCompletionsWithDefaultAgentError = CerebrasChatCompletionsWithDefaultAgentErrors[keyof CerebrasChatCompletionsWithDefaultAgentErrors];

export type CerebrasChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: CerebrasChatCompletionResponse;
};

export type CerebrasChatCompletionsWithDefaultAgentResponse = CerebrasChatCompletionsWithDefaultAgentResponses[keyof CerebrasChatCompletionsWithDefaultAgentResponses];

export type CerebrasChatCompletionsWithAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/cerebras/{agentId}/chat/completions';
};

export type CerebrasChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CerebrasChatCompletionsWithAgentError = CerebrasChatCompletionsWithAgentErrors[keyof CerebrasChatCompletionsWithAgentErrors];

export type CerebrasChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: CerebrasChatCompletionResponse;
};

export type CerebrasChatCompletionsWithAgentResponse = CerebrasChatCompletionsWithAgentResponses[keyof CerebrasChatCompletionsWithAgentResponses];

export type GetChatApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/chat-api-keys';
};

export type GetChatApiKeysErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatApiKeysError = GetChatApiKeysErrors[keyof GetChatApiKeysErrors];

export type GetChatApiKeysResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        organizationId: string;
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        secretId: string | null;
        scope: 'personal' | 'team' | 'org_wide';
        userId: string | null;
        teamId: string | null;
        isSystem: boolean;
        createdAt: string;
        updatedAt: string;
        teamName?: string | null;
        userName?: string | null;
        vaultSecretPath?: string | null;
        vaultSecretKey?: string | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
        bestModelId?: string | null;
        isAgentKey?: boolean;
    }>;
};

export type GetChatApiKeysResponse = GetChatApiKeysResponses[keyof GetChatApiKeysResponses];

export type CreateChatApiKeyData = {
    body: {
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        apiKey?: string;
        scope?: 'personal' | 'team' | 'org_wide';
        teamId?: string;
        vaultSecretPath?: string;
        vaultSecretKey?: string;
    };
    path?: never;
    query?: never;
    url: '/api/chat-api-keys';
};

export type CreateChatApiKeyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateChatApiKeyError = CreateChatApiKeyErrors[keyof CreateChatApiKeyErrors];

export type CreateChatApiKeyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        secretId: string | null;
        scope: 'personal' | 'team' | 'org_wide';
        userId: string | null;
        teamId: string | null;
        isSystem: boolean;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateChatApiKeyResponse = CreateChatApiKeyResponses[keyof CreateChatApiKeyResponses];

export type GetAvailableChatApiKeysData = {
    body?: never;
    path?: never;
    query?: {
        provider?: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        includeKeyId?: string;
    };
    url: '/api/chat-api-keys/available';
};

export type GetAvailableChatApiKeysErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAvailableChatApiKeysError = GetAvailableChatApiKeysErrors[keyof GetAvailableChatApiKeysErrors];

export type GetAvailableChatApiKeysResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        organizationId: string;
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        secretId: string | null;
        scope: 'personal' | 'team' | 'org_wide';
        userId: string | null;
        teamId: string | null;
        isSystem: boolean;
        createdAt: string;
        updatedAt: string;
        teamName?: string | null;
        userName?: string | null;
        vaultSecretPath?: string | null;
        vaultSecretKey?: string | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
        bestModelId?: string | null;
        isAgentKey?: boolean;
    }>;
};

export type GetAvailableChatApiKeysResponse = GetAvailableChatApiKeysResponses[keyof GetAvailableChatApiKeysResponses];

export type DeleteChatApiKeyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat-api-keys/{id}';
};

export type DeleteChatApiKeyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteChatApiKeyError = DeleteChatApiKeyErrors[keyof DeleteChatApiKeyErrors];

export type DeleteChatApiKeyResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteChatApiKeyResponse = DeleteChatApiKeyResponses[keyof DeleteChatApiKeyResponses];

export type GetChatApiKeyData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat-api-keys/{id}';
};

export type GetChatApiKeyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatApiKeyError = GetChatApiKeyErrors[keyof GetChatApiKeyErrors];

export type GetChatApiKeyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        secretId: string | null;
        scope: 'personal' | 'team' | 'org_wide';
        userId: string | null;
        teamId: string | null;
        isSystem: boolean;
        createdAt: string;
        updatedAt: string;
        teamName?: string | null;
        userName?: string | null;
        vaultSecretPath?: string | null;
        vaultSecretKey?: string | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
        bestModelId?: string | null;
        isAgentKey?: boolean;
    };
};

export type GetChatApiKeyResponse = GetChatApiKeyResponses[keyof GetChatApiKeyResponses];

export type UpdateChatApiKeyData = {
    body?: {
        name?: string;
        apiKey?: string;
        scope?: 'personal' | 'team' | 'org_wide';
        teamId?: string | null;
        vaultSecretPath?: string;
        vaultSecretKey?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat-api-keys/{id}';
};

export type UpdateChatApiKeyErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateChatApiKeyError = UpdateChatApiKeyErrors[keyof UpdateChatApiKeyErrors];

export type UpdateChatApiKeyResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        name: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        secretId: string | null;
        scope: 'personal' | 'team' | 'org_wide';
        userId: string | null;
        teamId: string | null;
        isSystem: boolean;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateChatApiKeyResponse = UpdateChatApiKeyResponses[keyof UpdateChatApiKeyResponses];

export type GetChatModelsData = {
    body?: never;
    path?: never;
    query?: {
        provider?: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
    };
    url: '/api/chat/models';
};

export type GetChatModelsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatModelsError = GetChatModelsErrors[keyof GetChatModelsErrors];

export type GetChatModelsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        displayName: string;
        provider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        createdAt?: string;
        capabilities?: {
            contextLength: number | null;
            inputModalities: Array<'text' | 'image' | 'audio' | 'video' | 'pdf'> | null;
            outputModalities: Array<'text' | 'image' | 'audio'> | null;
            supportsToolCalling: boolean | null;
            pricePerMillionInput: string | null;
            pricePerMillionOutput: string | null;
        };
    }>;
};

export type GetChatModelsResponse = GetChatModelsResponses[keyof GetChatModelsResponses];

export type SyncChatModelsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/chat/models/sync';
};

export type SyncChatModelsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type SyncChatModelsError = SyncChatModelsErrors[keyof SyncChatModelsErrors];

export type SyncChatModelsResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type SyncChatModelsResponse = SyncChatModelsResponses[keyof SyncChatModelsResponses];

export type GetModelsWithApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/models';
};

export type GetModelsWithApiKeysErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetModelsWithApiKeysError = GetModelsWithApiKeysErrors[keyof GetModelsWithApiKeysErrors];

export type GetModelsWithApiKeysResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        externalId: string;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        modelId: string;
        description: string | null;
        contextLength: number | null;
        inputModalities: Array<'text' | 'image' | 'audio' | 'video' | 'pdf'> | null;
        outputModalities: Array<'text' | 'image' | 'audio'> | null;
        supportsToolCalling: boolean | null;
        promptPricePerToken: string | null;
        completionPricePerToken: string | null;
        lastSyncedAt: string;
        createdAt: string;
        updatedAt: string;
        isFastest: boolean;
        isBest: boolean;
        apiKeys: Array<{
            id: string;
            name: string;
            provider: string;
            scope: string;
            isSystem: boolean;
        }>;
        capabilities: {
            contextLength: number | null;
            inputModalities: Array<'text' | 'image' | 'audio' | 'video' | 'pdf'> | null;
            outputModalities: Array<'text' | 'image' | 'audio'> | null;
            supportsToolCalling: boolean | null;
            pricePerMillionInput: string | null;
            pricePerMillionOutput: string | null;
        };
    }>;
};

export type GetModelsWithApiKeysResponse = GetModelsWithApiKeysResponses[keyof GetModelsWithApiKeysResponses];

export type StreamChatData = {
    body: {
        id: string;
        messages: Array<unknown>;
        trigger?: 'submit-message' | 'regenerate-message';
    };
    path?: never;
    query?: never;
    url: '/api/chat';
};

export type StreamChatErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type StreamChatError = StreamChatErrors[keyof StreamChatErrors];

export type StopChatStreamData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}/stop';
};

export type StopChatStreamErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type StopChatStreamError = StopChatStreamErrors[keyof StopChatStreamErrors];

export type StopChatStreamResponses = {
    /**
     * Default Response
     */
    200: {
        stopped: boolean;
    };
};

export type StopChatStreamResponse = StopChatStreamResponses[keyof StopChatStreamResponses];

export type GetChatConversationsData = {
    body?: never;
    path?: never;
    query?: {
        search?: string;
    };
    url: '/api/chat/conversations';
};

export type GetChatConversationsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatConversationsError = GetChatConversationsErrors[keyof GetChatConversationsErrors];

export type GetChatConversationsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    }>;
};

export type GetChatConversationsResponse = GetChatConversationsResponses[keyof GetChatConversationsResponses];

export type CreateChatConversationData = {
    body: {
        agentId: string;
        title?: string | null;
        selectedModel?: string;
        selectedProvider?: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        chatApiKeyId?: string | null;
    };
    path?: never;
    query?: never;
    url: '/api/chat/conversations';
};

export type CreateChatConversationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateChatConversationError = CreateChatConversationErrors[keyof CreateChatConversationErrors];

export type CreateChatConversationResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    };
};

export type CreateChatConversationResponse = CreateChatConversationResponses[keyof CreateChatConversationResponses];

export type DeleteChatConversationData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}';
};

export type DeleteChatConversationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteChatConversationError = DeleteChatConversationErrors[keyof DeleteChatConversationErrors];

export type DeleteChatConversationResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteChatConversationResponse = DeleteChatConversationResponses[keyof DeleteChatConversationResponses];

export type GetChatConversationData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}';
};

export type GetChatConversationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatConversationError = GetChatConversationErrors[keyof GetChatConversationErrors];

export type GetChatConversationResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    };
};

export type GetChatConversationResponse = GetChatConversationResponses[keyof GetChatConversationResponses];

export type UpdateChatConversationData = {
    body?: {
        title?: string | null;
        selectedModel?: string;
        selectedProvider?: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        chatApiKeyId?: string | null;
        agentId?: string;
        artifact?: string | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}';
};

export type UpdateChatConversationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateChatConversationError = UpdateChatConversationErrors[keyof UpdateChatConversationErrors];

export type UpdateChatConversationResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    };
};

export type UpdateChatConversationResponse = UpdateChatConversationResponses[keyof UpdateChatConversationResponses];

export type GetChatAgentMcpToolsData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/chat/agents/{agentId}/mcp-tools';
};

export type GetChatAgentMcpToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatAgentMcpToolsError = GetChatAgentMcpToolsErrors[keyof GetChatAgentMcpToolsErrors];

export type GetChatAgentMcpToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        name: string;
        description: string;
        parameters: {
            [key: string]: unknown;
        } | null;
    }>;
};

export type GetChatAgentMcpToolsResponse = GetChatAgentMcpToolsResponses[keyof GetChatAgentMcpToolsResponses];

export type GenerateChatConversationTitleData = {
    body?: {
        /**
         * Force regeneration even if title already exists (for manual regeneration)
         */
        regenerate?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}/generate-title';
};

export type GenerateChatConversationTitleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GenerateChatConversationTitleError = GenerateChatConversationTitleErrors[keyof GenerateChatConversationTitleErrors];

export type GenerateChatConversationTitleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    };
};

export type GenerateChatConversationTitleResponse = GenerateChatConversationTitleResponses[keyof GenerateChatConversationTitleResponses];

export type UpdateChatMessageData = {
    body: {
        partIndex: number;
        text: string;
        deleteSubsequentMessages?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/messages/{id}';
};

export type UpdateChatMessageErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateChatMessageError = UpdateChatMessageErrors[keyof UpdateChatMessageErrors];

export type UpdateChatMessageResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        userId: string;
        organizationId: string;
        agentId: string;
        chatApiKeyId: string | null;
        title: string | null;
        selectedModel: string;
        selectedProvider: 'anthropic' | 'bedrock' | 'cerebras' | 'cohere' | 'gemini' | 'mistral' | 'openai' | 'vllm' | 'ollama' | 'zhipuai';
        hasCustomToolSelection: boolean;
        todoList: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown> | null;
        artifact: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
            systemPrompt: string | null;
            userPrompt: string | null;
            agentType: 'profile' | 'mcp_gateway' | 'llm_proxy' | 'agent';
            llmApiKeyId: string | null;
        };
        messages: Array<unknown>;
    };
};

export type UpdateChatMessageResponse = UpdateChatMessageResponses[keyof UpdateChatMessageResponses];

export type DeleteConversationEnabledToolsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}/enabled-tools';
};

export type DeleteConversationEnabledToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteConversationEnabledToolsError = DeleteConversationEnabledToolsErrors[keyof DeleteConversationEnabledToolsErrors];

export type DeleteConversationEnabledToolsResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteConversationEnabledToolsResponse = DeleteConversationEnabledToolsResponses[keyof DeleteConversationEnabledToolsResponses];

export type GetConversationEnabledToolsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}/enabled-tools';
};

export type GetConversationEnabledToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetConversationEnabledToolsError = GetConversationEnabledToolsErrors[keyof GetConversationEnabledToolsErrors];

export type GetConversationEnabledToolsResponses = {
    /**
     * Default Response
     */
    200: {
        hasCustomSelection: boolean;
        enabledToolIds: Array<string>;
    };
};

export type GetConversationEnabledToolsResponse = GetConversationEnabledToolsResponses[keyof GetConversationEnabledToolsResponses];

export type UpdateConversationEnabledToolsData = {
    body: {
        toolIds: Array<string>;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chat/conversations/{id}/enabled-tools';
};

export type UpdateConversationEnabledToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateConversationEnabledToolsError = UpdateConversationEnabledToolsErrors[keyof UpdateConversationEnabledToolsErrors];

export type UpdateConversationEnabledToolsResponses = {
    /**
     * Default Response
     */
    200: {
        hasCustomSelection: boolean;
        enabledToolIds: Array<string>;
    };
};

export type UpdateConversationEnabledToolsResponse = UpdateConversationEnabledToolsResponses[keyof UpdateConversationEnabledToolsResponses];

export type PostApiWebhooksChatopsMsTeamsData = {
    body?: unknown;
    path?: never;
    query?: never;
    url: '/api/webhooks/chatops/ms-teams';
};

export type PostApiWebhooksChatopsMsTeamsErrors = {
    /**
     * Default Response
     */
    400: {
        error: string;
    };
    /**
     * Default Response
     */
    429: {
        error: string;
    };
    /**
     * Default Response
     */
    500: {
        error: string;
    };
};

export type PostApiWebhooksChatopsMsTeamsError = PostApiWebhooksChatopsMsTeamsErrors[keyof PostApiWebhooksChatopsMsTeamsErrors];

export type PostApiWebhooksChatopsMsTeamsResponses = {
    /**
     * Default Response
     */
    200: {
        status: string;
    } | {
        success: boolean;
    };
};

export type PostApiWebhooksChatopsMsTeamsResponse = PostApiWebhooksChatopsMsTeamsResponses[keyof PostApiWebhooksChatopsMsTeamsResponses];

export type GetChatOpsStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/chatops/status';
};

export type GetChatOpsStatusErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetChatOpsStatusError = GetChatOpsStatusErrors[keyof GetChatOpsStatusErrors];

export type GetChatOpsStatusResponses = {
    /**
     * Default Response
     */
    200: {
        providers: Array<{
            id: string;
            displayName: string;
            configured: boolean;
            credentials?: {
                appId: string;
                appSecret: string;
                tenantId: string;
            };
        }>;
    };
};

export type GetChatOpsStatusResponse = GetChatOpsStatusResponses[keyof GetChatOpsStatusResponses];

export type ListChatOpsBindingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/chatops/bindings';
};

export type ListChatOpsBindingsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ListChatOpsBindingsError = ListChatOpsBindingsErrors[keyof ListChatOpsBindingsErrors];

export type ListChatOpsBindingsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        organizationId: string;
        provider: 'ms-teams';
        channelId: string;
        workspaceId: string | null;
        channelName: string | null;
        workspaceName: string | null;
        agentId: string | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type ListChatOpsBindingsResponse = ListChatOpsBindingsResponses[keyof ListChatOpsBindingsResponses];

export type DeleteChatOpsBindingData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chatops/bindings/{id}';
};

export type DeleteChatOpsBindingErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteChatOpsBindingError = DeleteChatOpsBindingErrors[keyof DeleteChatOpsBindingErrors];

export type DeleteChatOpsBindingResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteChatOpsBindingResponse = DeleteChatOpsBindingResponses[keyof DeleteChatOpsBindingResponses];

export type UpdateChatOpsBindingData = {
    body?: {
        agentId?: string | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/chatops/bindings/{id}';
};

export type UpdateChatOpsBindingErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateChatOpsBindingError = UpdateChatOpsBindingErrors[keyof UpdateChatOpsBindingErrors];

export type UpdateChatOpsBindingResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId: string;
        provider: 'ms-teams';
        channelId: string;
        workspaceId: string | null;
        channelName: string | null;
        workspaceName: string | null;
        agentId: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateChatOpsBindingResponse = UpdateChatOpsBindingResponses[keyof UpdateChatOpsBindingResponses];

export type UpdateChatOpsConfigInQuickstartData = {
    body?: {
        enabled?: boolean;
        appId?: string;
        appSecret?: string;
        tenantId?: string;
    };
    path?: never;
    query?: never;
    url: '/api/chatops/config/ms-teams';
};

export type UpdateChatOpsConfigInQuickstartErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateChatOpsConfigInQuickstartError = UpdateChatOpsConfigInQuickstartErrors[keyof UpdateChatOpsConfigInQuickstartErrors];

export type UpdateChatOpsConfigInQuickstartResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type UpdateChatOpsConfigInQuickstartResponse = UpdateChatOpsConfigInQuickstartResponses[keyof UpdateChatOpsConfigInQuickstartResponses];

export type RefreshChatOpsChannelDiscoveryData = {
    body: {
        provider: 'ms-teams';
    };
    path?: never;
    query?: never;
    url: '/api/chatops/channel-discovery/refresh';
};

export type RefreshChatOpsChannelDiscoveryErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RefreshChatOpsChannelDiscoveryError = RefreshChatOpsChannelDiscoveryErrors[keyof RefreshChatOpsChannelDiscoveryErrors];

export type RefreshChatOpsChannelDiscoveryResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type RefreshChatOpsChannelDiscoveryResponse = RefreshChatOpsChannelDiscoveryResponses[keyof RefreshChatOpsChannelDiscoveryResponses];

export type CohereChatWithDefaultAgentData = {
    body?: CohereChatRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for API auth
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/cohere/chat';
};

export type CohereChatWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CohereChatWithDefaultAgentError = CohereChatWithDefaultAgentErrors[keyof CohereChatWithDefaultAgentErrors];

export type CohereChatWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: CohereChatResponse;
};

export type CohereChatWithDefaultAgentResponse = CohereChatWithDefaultAgentResponses[keyof CohereChatWithDefaultAgentResponses];

export type CohereChatWithAgentData = {
    body?: CohereChatRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for API auth
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/cohere/{agentId}/chat';
};

export type CohereChatWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CohereChatWithAgentError = CohereChatWithAgentErrors[keyof CohereChatWithAgentErrors];

export type CohereChatWithAgentResponses = {
    /**
     * Default Response
     */
    200: CohereChatResponse;
};

export type CohereChatWithAgentResponse = CohereChatWithAgentResponses[keyof CohereChatWithAgentResponses];

export type GetDefaultDualLlmConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/dual-llm-config/default';
};

export type GetDefaultDualLlmConfigErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDefaultDualLlmConfigError = GetDefaultDualLlmConfigErrors[keyof GetDefaultDualLlmConfigErrors];

export type GetDefaultDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetDefaultDualLlmConfigResponse = GetDefaultDualLlmConfigResponses[keyof GetDefaultDualLlmConfigResponses];

export type GetDualLlmConfigsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/dual-llm-config';
};

export type GetDualLlmConfigsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDualLlmConfigsError = GetDualLlmConfigsErrors[keyof GetDualLlmConfigsErrors];

export type GetDualLlmConfigsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetDualLlmConfigsResponse = GetDualLlmConfigsResponses[keyof GetDualLlmConfigsResponses];

export type CreateDualLlmConfigData = {
    body: {
        enabled?: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds?: number;
    };
    path?: never;
    query?: never;
    url: '/api/dual-llm-config';
};

export type CreateDualLlmConfigErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateDualLlmConfigError = CreateDualLlmConfigErrors[keyof CreateDualLlmConfigErrors];

export type CreateDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateDualLlmConfigResponse = CreateDualLlmConfigResponses[keyof CreateDualLlmConfigResponses];

export type DeleteDualLlmConfigData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type DeleteDualLlmConfigErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteDualLlmConfigError = DeleteDualLlmConfigErrors[keyof DeleteDualLlmConfigErrors];

export type DeleteDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteDualLlmConfigResponse = DeleteDualLlmConfigResponses[keyof DeleteDualLlmConfigResponses];

export type GetDualLlmConfigData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type GetDualLlmConfigErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDualLlmConfigError = GetDualLlmConfigErrors[keyof GetDualLlmConfigErrors];

export type GetDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetDualLlmConfigResponse = GetDualLlmConfigResponses[keyof GetDualLlmConfigResponses];

export type UpdateDualLlmConfigData = {
    body?: {
        enabled?: boolean;
        mainAgentPrompt?: string;
        quarantinedAgentPrompt?: string;
        summaryPrompt?: string;
        maxRounds?: number;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/dual-llm-config/{id}';
};

export type UpdateDualLlmConfigErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateDualLlmConfigError = UpdateDualLlmConfigErrors[keyof UpdateDualLlmConfigErrors];

export type UpdateDualLlmConfigResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        enabled: boolean;
        mainAgentPrompt: string;
        quarantinedAgentPrompt: string;
        summaryPrompt: string;
        maxRounds: number;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateDualLlmConfigResponse = UpdateDualLlmConfigResponses[keyof UpdateDualLlmConfigResponses];

export type GetDualLlmResultByToolCallIdData = {
    body?: never;
    path: {
        toolCallId: string;
    };
    query?: never;
    url: '/api/dual-llm-results/by-tool-call-id/{toolCallId}';
};

export type GetDualLlmResultByToolCallIdErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDualLlmResultByToolCallIdError = GetDualLlmResultByToolCallIdErrors[keyof GetDualLlmResultByToolCallIdErrors];

export type GetDualLlmResultByToolCallIdResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentId: string;
        toolCallId: string;
        conversations: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown>;
        result: string;
        createdAt: string;
    } | null;
};

export type GetDualLlmResultByToolCallIdResponse = GetDualLlmResultByToolCallIdResponses[keyof GetDualLlmResultByToolCallIdResponses];

export type GetDualLlmResultsByInteractionData = {
    body?: never;
    path: {
        interactionId: string;
    };
    query?: never;
    url: '/api/dual-llm-results/by-interaction/{interactionId}';
};

export type GetDualLlmResultsByInteractionErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDualLlmResultsByInteractionError = GetDualLlmResultsByInteractionErrors[keyof GetDualLlmResultsByInteractionErrors];

export type GetDualLlmResultsByInteractionResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        agentId: string;
        toolCallId: string;
        conversations: string | number | boolean | null | {
            [key: string]: unknown;
        } | Array<unknown>;
        result: string;
        createdAt: string;
    }>;
};

export type GetDualLlmResultsByInteractionResponse = GetDualLlmResultsByInteractionResponses[keyof GetDualLlmResultsByInteractionResponses];

export type GetFeaturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/features';
};

export type GetFeaturesResponses = {
    /**
     * Default Response
     */
    200: {
        'orchestrator-k8s-runtime': boolean;
        byosEnabled: boolean;
        byosVaultKvVersion: '1' | '2';
        geminiVertexAiEnabled: boolean;
        vllmEnabled: boolean;
        ollamaEnabled: boolean;
        mistralEnabled: boolean;
        globalToolPolicy: 'permissive' | 'restrictive';
        browserStreamingEnabled: boolean;
        incomingEmail: {
            enabled: boolean;
            provider?: 'outlook';
            displayName?: string;
            emailDomain?: string;
        };
        knowledgeGraph: {
            enabled: boolean;
            provider?: 'lightrag';
            displayName?: string;
        };
        mcpServerBaseImage: string;
        orchestratorK8sNamespace: string;
        isQuickstart: boolean;
        ngrokDomain: string;
        chatops: {
            msTeamsEnabled: boolean;
            msTeamsAppId: boolean;
            msTeamsAppSecret: boolean;
            msTeamsTenantId: boolean;
        };
    };
};

export type GetFeaturesResponse = GetFeaturesResponses[keyof GetFeaturesResponses];

export type PostV1GeminiV1BetaModelsByModelGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini. Required for Google AI Studio mode, optional for Vertex AI mode (uses ADC).
         */
        'x-goog-api-key'?: string;
    };
    path: {
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/v1beta/models/{model}:generateContent';
};

export type PostV1GeminiV1BetaModelsByModelGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type PostV1GeminiV1BetaModelsByModelGenerateContentError = PostV1GeminiV1BetaModelsByModelGenerateContentErrors[keyof PostV1GeminiV1BetaModelsByModelGenerateContentErrors];

export type PostV1GeminiV1BetaModelsByModelGenerateContentResponses = {
    /**
     * Default Response
     */
    200: GeminiGenerateContentResponse;
};

export type PostV1GeminiV1BetaModelsByModelGenerateContentResponse = PostV1GeminiV1BetaModelsByModelGenerateContentResponses[keyof PostV1GeminiV1BetaModelsByModelGenerateContentResponses];

export type PostV1GeminiV1BetaModelsByModelStreamGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini. Required for Google AI Studio mode, optional for Vertex AI mode (uses ADC).
         */
        'x-goog-api-key'?: string;
    };
    path: {
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/v1beta/models/{model}:streamGenerateContent';
};

export type PostV1GeminiV1BetaModelsByModelStreamGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type PostV1GeminiV1BetaModelsByModelStreamGenerateContentError = PostV1GeminiV1BetaModelsByModelStreamGenerateContentErrors[keyof PostV1GeminiV1BetaModelsByModelStreamGenerateContentErrors];

export type PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini. Required for Google AI Studio mode, optional for Vertex AI mode (uses ADC).
         */
        'x-goog-api-key'?: string;
    };
    path: {
        agentId: string;
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/{agentId}/v1beta/models/{model}:generateContent';
};

export type PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentError = PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentErrors[keyof PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentErrors];

export type PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentResponses = {
    /**
     * Default Response
     */
    200: GeminiGenerateContentResponse;
};

export type PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentResponse = PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentResponses[keyof PostV1GeminiByAgentIdV1BetaModelsByModelGenerateContentResponses];

export type PostV1GeminiByAgentIdV1BetaModelsByModelStreamGenerateContentData = {
    body?: GeminiGenerateContentRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * API key for Google Gemini. Required for Google AI Studio mode, optional for Vertex AI mode (uses ADC).
         */
        'x-goog-api-key'?: string;
    };
    path: {
        agentId: string;
        /**
         * The model to use
         */
        model: string;
    };
    query?: never;
    url: '/v1/gemini/{agentId}/v1beta/models/{model}:streamGenerateContent';
};

export type PostV1GeminiByAgentIdV1BetaModelsByModelStreamGenerateContentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type PostV1GeminiByAgentIdV1BetaModelsByModelStreamGenerateContentError = PostV1GeminiByAgentIdV1BetaModelsByModelStreamGenerateContentErrors[keyof PostV1GeminiByAgentIdV1BetaModelsByModelStreamGenerateContentErrors];

export type PostApiWebhooksIncomingEmailData = {
    body?: unknown;
    path?: never;
    query?: never;
    url: '/api/webhooks/incoming-email';
};

export type PostApiWebhooksIncomingEmailErrors = {
    /**
     * Default Response
     */
    400: {
        error: string;
    };
    /**
     * Default Response
     */
    429: {
        error: string;
    };
    /**
     * Default Response
     */
    500: {
        error: string;
    };
};

export type PostApiWebhooksIncomingEmailError = PostApiWebhooksIncomingEmailErrors[keyof PostApiWebhooksIncomingEmailErrors];

export type PostApiWebhooksIncomingEmailResponses = {
    /**
     * Default Response
     */
    200: string | {
        success: boolean;
        processed?: number;
        errors?: number;
    };
};

export type PostApiWebhooksIncomingEmailResponse = PostApiWebhooksIncomingEmailResponses[keyof PostApiWebhooksIncomingEmailResponses];

export type GetAgentEmailAddressData = {
    body?: never;
    path: {
        agentId: string;
    };
    query?: never;
    url: '/api/agents/{agentId}/email-address';
};

export type GetAgentEmailAddressErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentEmailAddressError = GetAgentEmailAddressErrors[keyof GetAgentEmailAddressErrors];

export type GetAgentEmailAddressResponses = {
    /**
     * Default Response
     */
    200: {
        providerEnabled: boolean;
        emailAddress: string | null;
        agentIncomingEmailEnabled: boolean;
        agentSecurityMode: 'private' | 'internal' | 'public';
        agentAllowedDomain: string | null;
    };
};

export type GetAgentEmailAddressResponse = GetAgentEmailAddressResponses[keyof GetAgentEmailAddressResponses];

export type GetIncomingEmailStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/incoming-email/status';
};

export type GetIncomingEmailStatusErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetIncomingEmailStatusError = GetIncomingEmailStatusErrors[keyof GetIncomingEmailStatusErrors];

export type GetIncomingEmailStatusResponses = {
    /**
     * Default Response
     */
    200: {
        isActive: boolean;
        subscription: {
            id: string;
            subscriptionId: string;
            provider: string;
            webhookUrl: string;
            expiresAt: string;
        } | null;
    };
};

export type GetIncomingEmailStatusResponse = GetIncomingEmailStatusResponses[keyof GetIncomingEmailStatusResponses];

export type SetupIncomingEmailWebhookData = {
    body: {
        webhookUrl: string;
    };
    path?: never;
    query?: never;
    url: '/api/incoming-email/setup';
};

export type SetupIncomingEmailWebhookErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type SetupIncomingEmailWebhookError = SetupIncomingEmailWebhookErrors[keyof SetupIncomingEmailWebhookErrors];

export type SetupIncomingEmailWebhookResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
        subscriptionId?: string;
        expiresAt?: string;
        message?: string;
    };
};

export type SetupIncomingEmailWebhookResponse = SetupIncomingEmailWebhookResponses[keyof SetupIncomingEmailWebhookResponses];

export type RenewIncomingEmailSubscriptionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/incoming-email/renew';
};

export type RenewIncomingEmailSubscriptionErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RenewIncomingEmailSubscriptionError = RenewIncomingEmailSubscriptionErrors[keyof RenewIncomingEmailSubscriptionErrors];

export type RenewIncomingEmailSubscriptionResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
        subscriptionId?: string;
        expiresAt?: string;
        message?: string;
    };
};

export type RenewIncomingEmailSubscriptionResponse = RenewIncomingEmailSubscriptionResponses[keyof RenewIncomingEmailSubscriptionResponses];

export type DeleteIncomingEmailSubscriptionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/incoming-email/subscription';
};

export type DeleteIncomingEmailSubscriptionErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteIncomingEmailSubscriptionError = DeleteIncomingEmailSubscriptionErrors[keyof DeleteIncomingEmailSubscriptionErrors];

export type DeleteIncomingEmailSubscriptionResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteIncomingEmailSubscriptionResponse = DeleteIncomingEmailSubscriptionResponses[keyof DeleteIncomingEmailSubscriptionResponses];

export type GetInteractionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by profile ID (internal Archestra profile)
         */
        profileId?: string;
        /**
         * Filter by external agent ID (from X-Archestra-Agent-Id header)
         */
        externalAgentId?: string;
        /**
         * Filter by user ID (from X-Archestra-User-Id header)
         */
        userId?: string;
        /**
         * Filter by session ID
         */
        sessionId?: string;
        /**
         * Filter by start date (ISO 8601 format)
         */
        startDate?: string;
        /**
         * Filter by end date (ISO 8601 format)
         */
        endDate?: string;
        limit?: number;
        offset?: number;
        sortBy?: 'createdAt' | 'profileId' | 'externalAgentId' | 'model' | 'userId';
        sortDirection?: 'asc' | 'desc';
    };
    url: '/api/interactions';
};

export type GetInteractionsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInteractionsError = GetInteractionsErrors[keyof GetInteractionsErrors];

export type GetInteractionsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: MistralChatCompletionRequest;
            processedRequest?: MistralChatCompletionRequest | null;
            response: OpenAiChatCompletionResponse;
            type: 'openai:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: GeminiGenerateContentRequest;
            processedRequest?: GeminiGenerateContentRequest | null;
            response: GeminiGenerateContentResponse;
            type: 'gemini:generateContent';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: AnthropicMessagesRequest;
            processedRequest?: AnthropicMessagesRequest | null;
            response: AnthropicMessagesResponse;
            type: 'anthropic:messages';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: {
                modelId: string;
                messages?: Array<{
                    role: 'user' | 'assistant';
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        guardContent: {
                            text: {
                                text: string;
                                qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                            };
                        };
                    } | {
                        toolUse: {
                            toolUseId: string;
                            name: string;
                            input: {
                                [key: string]: unknown;
                            };
                        };
                    } | {
                        toolResult: {
                            toolUseId: string;
                            content: Array<{
                                text: string;
                            } | {
                                image: {
                                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                                    source: {
                                        bytes: string;
                                    } | {
                                        s3Location: {
                                            uri: string;
                                            bucketOwner?: string;
                                        };
                                    };
                                };
                            } | {
                                json: {
                                    [key: string]: unknown;
                                };
                            } | {
                                document: {
                                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                                    name: string;
                                    source: {
                                        bytes: string;
                                    } | {
                                        s3Location: {
                                            uri: string;
                                            bucketOwner?: string;
                                        };
                                    };
                                };
                            }>;
                            status?: 'success' | 'error';
                        };
                    }>;
                }>;
                system?: Array<{
                    text: string;
                } | {
                    guardContent: {
                        text: {
                            text: string;
                            qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                        };
                    };
                }>;
                inferenceConfig?: {
                    maxTokens?: number;
                    temperature?: number;
                    topP?: number;
                    stopSequences?: Array<string>;
                };
                toolConfig?: {
                    tools: Array<{
                        toolSpec: {
                            name: string;
                            description?: string;
                            inputSchema: {
                                json: {
                                    [key: string]: unknown;
                                };
                            };
                        };
                    }>;
                    toolChoice?: {
                        auto?: {
                            [key: string]: never;
                        };
                    } | {
                        any?: {
                            [key: string]: never;
                        };
                    } | {
                        tool: {
                            name: string;
                        };
                    };
                };
                guardrailConfig?: {
                    guardrailIdentifier: string;
                    guardrailVersion: string;
                    trace?: 'enabled' | 'disabled';
                };
                additionalModelRequestFields?: {
                    [key: string]: unknown;
                };
                additionalModelResponseFieldPaths?: Array<string>;
                promptVariables?: {
                    [key: string]: {
                        text: string;
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
                performanceConfig?: {
                    latency?: 'optimized';
                };
                serviceTier?: {
                    type?: 'default' | 'throughput';
                };
                requestMetadata?: {
                    [key: string]: string;
                };
                _isStreaming?: boolean;
            };
            processedRequest?: {
                modelId: string;
                messages?: Array<{
                    role: 'user' | 'assistant';
                    content: Array<{
                        text: string;
                    } | {
                        image: {
                            format: 'png' | 'jpeg' | 'gif' | 'webp';
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        document: {
                            format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                            name: string;
                            source: {
                                bytes: string;
                            } | {
                                s3Location: {
                                    uri: string;
                                    bucketOwner?: string;
                                };
                            };
                        };
                    } | {
                        guardContent: {
                            text: {
                                text: string;
                                qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                            };
                        };
                    } | {
                        toolUse: {
                            toolUseId: string;
                            name: string;
                            input: {
                                [key: string]: unknown;
                            };
                        };
                    } | {
                        toolResult: {
                            toolUseId: string;
                            content: Array<{
                                text: string;
                            } | {
                                image: {
                                    format: 'png' | 'jpeg' | 'gif' | 'webp';
                                    source: {
                                        bytes: string;
                                    } | {
                                        s3Location: {
                                            uri: string;
                                            bucketOwner?: string;
                                        };
                                    };
                                };
                            } | {
                                json: {
                                    [key: string]: unknown;
                                };
                            } | {
                                document: {
                                    format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                                    name: string;
                                    source: {
                                        bytes: string;
                                    } | {
                                        s3Location: {
                                            uri: string;
                                            bucketOwner?: string;
                                        };
                                    };
                                };
                            }>;
                            status?: 'success' | 'error';
                        };
                    }>;
                }>;
                system?: Array<{
                    text: string;
                } | {
                    guardContent: {
                        text: {
                            text: string;
                            qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                        };
                    };
                }>;
                inferenceConfig?: {
                    maxTokens?: number;
                    temperature?: number;
                    topP?: number;
                    stopSequences?: Array<string>;
                };
                toolConfig?: {
                    tools: Array<{
                        toolSpec: {
                            name: string;
                            description?: string;
                            inputSchema: {
                                json: {
                                    [key: string]: unknown;
                                };
                            };
                        };
                    }>;
                    toolChoice?: {
                        auto?: {
                            [key: string]: never;
                        };
                    } | {
                        any?: {
                            [key: string]: never;
                        };
                    } | {
                        tool: {
                            name: string;
                        };
                    };
                };
                guardrailConfig?: {
                    guardrailIdentifier: string;
                    guardrailVersion: string;
                    trace?: 'enabled' | 'disabled';
                };
                additionalModelRequestFields?: {
                    [key: string]: unknown;
                };
                additionalModelResponseFieldPaths?: Array<string>;
                promptVariables?: {
                    [key: string]: {
                        text: string;
                    } | {
                        json: {
                            [key: string]: unknown;
                        };
                    };
                };
                performanceConfig?: {
                    latency?: 'optimized';
                };
                serviceTier?: {
                    type?: 'default' | 'throughput';
                };
                requestMetadata?: {
                    [key: string]: string;
                };
                _isStreaming?: boolean;
            } | null;
            response: {
                $metadata?: {
                    httpStatusCode?: number;
                    requestId?: string;
                    attempts?: number;
                    totalRetryDelay?: number;
                };
                output: {
                    message?: {
                        role: 'assistant';
                        content: Array<{
                            text: string;
                        } | {
                            toolUse: {
                                toolUseId: string;
                                name: string;
                                input: {
                                    [key: string]: unknown;
                                };
                            };
                        }>;
                    };
                };
                stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | 'model_context_window_exceeded';
                usage: {
                    inputTokens: number;
                    outputTokens: number;
                    totalTokens?: number;
                    cacheReadInputTokens?: number;
                    cacheWriteInputTokens?: number;
                };
                metrics?: {
                    latencyMs?: number;
                };
                additionalModelResponseFields?: {
                    [key: string]: unknown;
                };
                trace?: {
                    guardrail?: {
                        inputAssessment?: {
                            [key: string]: unknown;
                        };
                        outputAssessments?: {
                            [key: string]: unknown;
                        };
                        modelOutput?: Array<string>;
                        actionReason?: string;
                    };
                    promptRouter?: {
                        invokedModelId?: string;
                    };
                };
                performanceConfig?: {
                    latency?: 'optimized';
                };
                serviceTier?: {
                    type?: 'default' | 'throughput';
                };
            };
            type: 'bedrock:converse';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: MistralChatCompletionRequest;
            processedRequest?: MistralChatCompletionRequest | null;
            response: CerebrasChatCompletionResponse;
            type: 'cerebras:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: MistralChatCompletionRequest;
            processedRequest?: MistralChatCompletionRequest | null;
            response: MistralChatCompletionResponse;
            type: 'mistral:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: VllmChatCompletionRequest;
            processedRequest?: VllmChatCompletionRequest | null;
            response: VllmChatCompletionResponse;
            type: 'vllm:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: OllamaChatCompletionRequest;
            processedRequest?: OllamaChatCompletionRequest | null;
            response: OllamaChatCompletionResponse;
            type: 'ollama:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: CohereChatRequest;
            processedRequest?: CohereChatRequest | null;
            response: CohereChatResponse;
            type: 'cohere:chat';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        } | {
            id: string;
            profileId: string;
            externalAgentId: string | null;
            executionId: string | null;
            userId: string | null;
            sessionId: string | null;
            sessionSource: string | null;
            request: ZhipuaiChatCompletionRequest;
            processedRequest?: ZhipuaiChatCompletionRequest | null;
            response: ZhipuaiChatCompletionResponse;
            type: 'zhipuai:chatCompletions';
            model: string | null;
            baselineModel: string | null;
            inputTokens: number | null;
            outputTokens: number | null;
            baselineCost: string | null;
            cost: string | null;
            toonTokensBefore: number | null;
            toonTokensAfter: number | null;
            toonCostSavings: string | null;
            toonSkipReason: string | null;
            createdAt: string;
            requestType?: 'main' | 'subagent';
            externalAgentIdLabel?: string | null;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetInteractionsResponse = GetInteractionsResponses[keyof GetInteractionsResponses];

export type GetInteractionSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by profile ID (internal Archestra profile)
         */
        profileId?: string;
        /**
         * Filter by user ID (from X-Archestra-User-Id header)
         */
        userId?: string;
        /**
         * Filter by session ID
         */
        sessionId?: string;
        /**
         * Filter by start date (ISO 8601 format)
         */
        startDate?: string;
        /**
         * Filter by end date (ISO 8601 format)
         */
        endDate?: string;
        /**
         * Free-text search across session content (case-insensitive)
         */
        search?: string;
        limit?: number;
        offset?: number;
    };
    url: '/api/interactions/sessions';
};

export type GetInteractionSessionsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInteractionSessionsError = GetInteractionSessionsErrors[keyof GetInteractionSessionsErrors];

export type GetInteractionSessionsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            sessionId: string | null;
            sessionSource: string | null;
            interactionId: string | null;
            requestCount: number;
            totalInputTokens: number;
            totalOutputTokens: number;
            totalCost: string | null;
            totalBaselineCost: string | null;
            totalToonCostSavings: string | null;
            toonSkipReasonCounts: {
                applied: number;
                notEnabled: number;
                notEffective: number;
                noToolResults: number;
            };
            firstRequestTime: string;
            lastRequestTime: string;
            models: Array<string>;
            profileId: string;
            profileName: string | null;
            externalAgentIds: Array<string>;
            externalAgentIdLabels: Array<string | null>;
            userNames: Array<string>;
            lastInteractionRequest: unknown;
            lastInteractionType: string | null;
            conversationTitle: string | null;
            claudeCodeTitle: string | null;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetInteractionSessionsResponse = GetInteractionSessionsResponses[keyof GetInteractionSessionsResponses];

export type GetUniqueExternalAgentIdsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/interactions/external-agent-ids';
};

export type GetUniqueExternalAgentIdsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetUniqueExternalAgentIdsError = GetUniqueExternalAgentIdsErrors[keyof GetUniqueExternalAgentIdsErrors];

export type GetUniqueExternalAgentIdsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        displayName: string;
    }>;
};

export type GetUniqueExternalAgentIdsResponse = GetUniqueExternalAgentIdsResponses[keyof GetUniqueExternalAgentIdsResponses];

export type GetUniqueUserIdsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/interactions/user-ids';
};

export type GetUniqueUserIdsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetUniqueUserIdsError = GetUniqueUserIdsErrors[keyof GetUniqueUserIdsErrors];

export type GetUniqueUserIdsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
    }>;
};

export type GetUniqueUserIdsResponse = GetUniqueUserIdsResponses[keyof GetUniqueUserIdsResponses];

export type GetInteractionData = {
    body?: never;
    path: {
        interactionId: string;
    };
    query?: never;
    url: '/api/interactions/{interactionId}';
};

export type GetInteractionErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInteractionError = GetInteractionErrors[keyof GetInteractionErrors];

export type GetInteractionResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: MistralChatCompletionRequest;
        processedRequest?: MistralChatCompletionRequest | null;
        response: OpenAiChatCompletionResponse;
        type: 'openai:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: GeminiGenerateContentRequest;
        processedRequest?: GeminiGenerateContentRequest | null;
        response: GeminiGenerateContentResponse;
        type: 'gemini:generateContent';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: AnthropicMessagesRequest;
        processedRequest?: AnthropicMessagesRequest | null;
        response: AnthropicMessagesResponse;
        type: 'anthropic:messages';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: {
            modelId: string;
            messages?: Array<{
                role: 'user' | 'assistant';
                content: Array<{
                    text: string;
                } | {
                    image: {
                        format: 'png' | 'jpeg' | 'gif' | 'webp';
                        source: {
                            bytes: string;
                        } | {
                            s3Location: {
                                uri: string;
                                bucketOwner?: string;
                            };
                        };
                    };
                } | {
                    document: {
                        format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                        name: string;
                        source: {
                            bytes: string;
                        } | {
                            s3Location: {
                                uri: string;
                                bucketOwner?: string;
                            };
                        };
                    };
                } | {
                    guardContent: {
                        text: {
                            text: string;
                            qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                        };
                    };
                } | {
                    toolUse: {
                        toolUseId: string;
                        name: string;
                        input: {
                            [key: string]: unknown;
                        };
                    };
                } | {
                    toolResult: {
                        toolUseId: string;
                        content: Array<{
                            text: string;
                        } | {
                            image: {
                                format: 'png' | 'jpeg' | 'gif' | 'webp';
                                source: {
                                    bytes: string;
                                } | {
                                    s3Location: {
                                        uri: string;
                                        bucketOwner?: string;
                                    };
                                };
                            };
                        } | {
                            json: {
                                [key: string]: unknown;
                            };
                        } | {
                            document: {
                                format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                                name: string;
                                source: {
                                    bytes: string;
                                } | {
                                    s3Location: {
                                        uri: string;
                                        bucketOwner?: string;
                                    };
                                };
                            };
                        }>;
                        status?: 'success' | 'error';
                    };
                }>;
            }>;
            system?: Array<{
                text: string;
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            }>;
            inferenceConfig?: {
                maxTokens?: number;
                temperature?: number;
                topP?: number;
                stopSequences?: Array<string>;
            };
            toolConfig?: {
                tools: Array<{
                    toolSpec: {
                        name: string;
                        description?: string;
                        inputSchema: {
                            json: {
                                [key: string]: unknown;
                            };
                        };
                    };
                }>;
                toolChoice?: {
                    auto?: {
                        [key: string]: never;
                    };
                } | {
                    any?: {
                        [key: string]: never;
                    };
                } | {
                    tool: {
                        name: string;
                    };
                };
            };
            guardrailConfig?: {
                guardrailIdentifier: string;
                guardrailVersion: string;
                trace?: 'enabled' | 'disabled';
            };
            additionalModelRequestFields?: {
                [key: string]: unknown;
            };
            additionalModelResponseFieldPaths?: Array<string>;
            promptVariables?: {
                [key: string]: {
                    text: string;
                } | {
                    json: {
                        [key: string]: unknown;
                    };
                };
            };
            performanceConfig?: {
                latency?: 'optimized';
            };
            serviceTier?: {
                type?: 'default' | 'throughput';
            };
            requestMetadata?: {
                [key: string]: string;
            };
            _isStreaming?: boolean;
        };
        processedRequest?: {
            modelId: string;
            messages?: Array<{
                role: 'user' | 'assistant';
                content: Array<{
                    text: string;
                } | {
                    image: {
                        format: 'png' | 'jpeg' | 'gif' | 'webp';
                        source: {
                            bytes: string;
                        } | {
                            s3Location: {
                                uri: string;
                                bucketOwner?: string;
                            };
                        };
                    };
                } | {
                    document: {
                        format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                        name: string;
                        source: {
                            bytes: string;
                        } | {
                            s3Location: {
                                uri: string;
                                bucketOwner?: string;
                            };
                        };
                    };
                } | {
                    guardContent: {
                        text: {
                            text: string;
                            qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                        };
                    };
                } | {
                    toolUse: {
                        toolUseId: string;
                        name: string;
                        input: {
                            [key: string]: unknown;
                        };
                    };
                } | {
                    toolResult: {
                        toolUseId: string;
                        content: Array<{
                            text: string;
                        } | {
                            image: {
                                format: 'png' | 'jpeg' | 'gif' | 'webp';
                                source: {
                                    bytes: string;
                                } | {
                                    s3Location: {
                                        uri: string;
                                        bucketOwner?: string;
                                    };
                                };
                            };
                        } | {
                            json: {
                                [key: string]: unknown;
                            };
                        } | {
                            document: {
                                format: 'pdf' | 'csv' | 'doc' | 'docx' | 'xls' | 'xlsx' | 'html' | 'txt' | 'md';
                                name: string;
                                source: {
                                    bytes: string;
                                } | {
                                    s3Location: {
                                        uri: string;
                                        bucketOwner?: string;
                                    };
                                };
                            };
                        }>;
                        status?: 'success' | 'error';
                    };
                }>;
            }>;
            system?: Array<{
                text: string;
            } | {
                guardContent: {
                    text: {
                        text: string;
                        qualifiers?: Array<'grounding_source' | 'query' | 'guard_content'>;
                    };
                };
            }>;
            inferenceConfig?: {
                maxTokens?: number;
                temperature?: number;
                topP?: number;
                stopSequences?: Array<string>;
            };
            toolConfig?: {
                tools: Array<{
                    toolSpec: {
                        name: string;
                        description?: string;
                        inputSchema: {
                            json: {
                                [key: string]: unknown;
                            };
                        };
                    };
                }>;
                toolChoice?: {
                    auto?: {
                        [key: string]: never;
                    };
                } | {
                    any?: {
                        [key: string]: never;
                    };
                } | {
                    tool: {
                        name: string;
                    };
                };
            };
            guardrailConfig?: {
                guardrailIdentifier: string;
                guardrailVersion: string;
                trace?: 'enabled' | 'disabled';
            };
            additionalModelRequestFields?: {
                [key: string]: unknown;
            };
            additionalModelResponseFieldPaths?: Array<string>;
            promptVariables?: {
                [key: string]: {
                    text: string;
                } | {
                    json: {
                        [key: string]: unknown;
                    };
                };
            };
            performanceConfig?: {
                latency?: 'optimized';
            };
            serviceTier?: {
                type?: 'default' | 'throughput';
            };
            requestMetadata?: {
                [key: string]: string;
            };
            _isStreaming?: boolean;
        } | null;
        response: {
            $metadata?: {
                httpStatusCode?: number;
                requestId?: string;
                attempts?: number;
                totalRetryDelay?: number;
            };
            output: {
                message?: {
                    role: 'assistant';
                    content: Array<{
                        text: string;
                    } | {
                        toolUse: {
                            toolUseId: string;
                            name: string;
                            input: {
                                [key: string]: unknown;
                            };
                        };
                    }>;
                };
            };
            stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | 'model_context_window_exceeded';
            usage: {
                inputTokens: number;
                outputTokens: number;
                totalTokens?: number;
                cacheReadInputTokens?: number;
                cacheWriteInputTokens?: number;
            };
            metrics?: {
                latencyMs?: number;
            };
            additionalModelResponseFields?: {
                [key: string]: unknown;
            };
            trace?: {
                guardrail?: {
                    inputAssessment?: {
                        [key: string]: unknown;
                    };
                    outputAssessments?: {
                        [key: string]: unknown;
                    };
                    modelOutput?: Array<string>;
                    actionReason?: string;
                };
                promptRouter?: {
                    invokedModelId?: string;
                };
            };
            performanceConfig?: {
                latency?: 'optimized';
            };
            serviceTier?: {
                type?: 'default' | 'throughput';
            };
        };
        type: 'bedrock:converse';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: MistralChatCompletionRequest;
        processedRequest?: MistralChatCompletionRequest | null;
        response: CerebrasChatCompletionResponse;
        type: 'cerebras:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: MistralChatCompletionRequest;
        processedRequest?: MistralChatCompletionRequest | null;
        response: MistralChatCompletionResponse;
        type: 'mistral:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: VllmChatCompletionRequest;
        processedRequest?: VllmChatCompletionRequest | null;
        response: VllmChatCompletionResponse;
        type: 'vllm:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: OllamaChatCompletionRequest;
        processedRequest?: OllamaChatCompletionRequest | null;
        response: OllamaChatCompletionResponse;
        type: 'ollama:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: CohereChatRequest;
        processedRequest?: CohereChatRequest | null;
        response: CohereChatResponse;
        type: 'cohere:chat';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    } | {
        id: string;
        profileId: string;
        externalAgentId: string | null;
        executionId: string | null;
        userId: string | null;
        sessionId: string | null;
        sessionSource: string | null;
        request: ZhipuaiChatCompletionRequest;
        processedRequest?: ZhipuaiChatCompletionRequest | null;
        response: ZhipuaiChatCompletionResponse;
        type: 'zhipuai:chatCompletions';
        model: string | null;
        baselineModel: string | null;
        inputTokens: number | null;
        outputTokens: number | null;
        baselineCost: string | null;
        cost: string | null;
        toonTokensBefore: number | null;
        toonTokensAfter: number | null;
        toonCostSavings: string | null;
        toonSkipReason: string | null;
        createdAt: string;
        requestType?: 'main' | 'subagent';
        externalAgentIdLabel?: string | null;
    };
};

export type GetInteractionResponse = GetInteractionResponses[keyof GetInteractionResponses];

export type GetInternalMcpCatalogData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/internal_mcp_catalog';
};

export type GetInternalMcpCatalogErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInternalMcpCatalogError = GetInternalMcpCatalogErrors[keyof GetInternalMcpCatalogErrors];

export type GetInternalMcpCatalogResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        instructions: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType: 'local' | 'remote' | 'builtin';
        serverUrl: string | null;
        docsUrl: string | null;
        clientSecretId: string | null;
        localConfigSecretId: string | null;
        localConfig: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            serviceAccount?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
        } | null;
        deploymentSpecYaml: string | null;
        userConfig: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetInternalMcpCatalogResponse = GetInternalMcpCatalogResponses[keyof GetInternalMcpCatalogResponses];

export type CreateInternalMcpCatalogItemData = {
    body: {
        id?: string;
        name: string;
        version?: string | null;
        description?: string | null;
        instructions?: string | null;
        repository?: string | null;
        installationCommand?: string | null;
        requiresAuth?: boolean;
        authDescription?: string | null;
        authFields?: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType: 'local' | 'remote' | 'builtin';
        serverUrl?: string | null;
        docsUrl?: string | null;
        clientSecretId?: string | null;
        localConfigSecretId?: string | null;
        localConfig?: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
            serviceAccount?: string;
        } | null;
        deploymentSpecYaml?: string | null;
        userConfig?: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig?: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        oauthClientSecretVaultPath?: string;
        oauthClientSecretVaultKey?: string;
        localConfigVaultPath?: string;
        localConfigVaultKey?: string;
    };
    path?: never;
    query?: never;
    url: '/api/internal_mcp_catalog';
};

export type CreateInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateInternalMcpCatalogItemError = CreateInternalMcpCatalogItemErrors[keyof CreateInternalMcpCatalogItemErrors];

export type CreateInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        instructions: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType: 'local' | 'remote' | 'builtin';
        serverUrl: string | null;
        docsUrl: string | null;
        clientSecretId: string | null;
        localConfigSecretId: string | null;
        localConfig: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            serviceAccount?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
        } | null;
        deploymentSpecYaml: string | null;
        userConfig: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateInternalMcpCatalogItemResponse = CreateInternalMcpCatalogItemResponses[keyof CreateInternalMcpCatalogItemResponses];

export type DeleteInternalMcpCatalogItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type DeleteInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteInternalMcpCatalogItemError = DeleteInternalMcpCatalogItemErrors[keyof DeleteInternalMcpCatalogItemErrors];

export type DeleteInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteInternalMcpCatalogItemResponse = DeleteInternalMcpCatalogItemResponses[keyof DeleteInternalMcpCatalogItemResponses];

export type GetInternalMcpCatalogItemData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type GetInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInternalMcpCatalogItemError = GetInternalMcpCatalogItemErrors[keyof GetInternalMcpCatalogItemErrors];

export type GetInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        instructions: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType: 'local' | 'remote' | 'builtin';
        serverUrl: string | null;
        docsUrl: string | null;
        clientSecretId: string | null;
        localConfigSecretId: string | null;
        localConfig: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            serviceAccount?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
        } | null;
        deploymentSpecYaml: string | null;
        userConfig: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetInternalMcpCatalogItemResponse = GetInternalMcpCatalogItemResponses[keyof GetInternalMcpCatalogItemResponses];

export type UpdateInternalMcpCatalogItemData = {
    body?: {
        name?: string;
        version?: string | null;
        description?: string | null;
        instructions?: string | null;
        repository?: string | null;
        installationCommand?: string | null;
        requiresAuth?: boolean;
        authDescription?: string | null;
        authFields?: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType?: 'local' | 'remote' | 'builtin';
        serverUrl?: string | null;
        docsUrl?: string | null;
        clientSecretId?: string | null;
        localConfigSecretId?: string | null;
        localConfig?: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
            serviceAccount?: string;
        } | null;
        deploymentSpecYaml?: string | null;
        userConfig?: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig?: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        oauthClientSecretVaultPath?: string;
        oauthClientSecretVaultKey?: string;
        localConfigVaultPath?: string;
        localConfigVaultKey?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}';
};

export type UpdateInternalMcpCatalogItemErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateInternalMcpCatalogItemError = UpdateInternalMcpCatalogItemErrors[keyof UpdateInternalMcpCatalogItemErrors];

export type UpdateInternalMcpCatalogItemResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        version: string | null;
        description: string | null;
        instructions: string | null;
        repository: string | null;
        installationCommand: string | null;
        requiresAuth: boolean;
        authDescription: string | null;
        authFields: Array<{
            name: string;
            label: string;
            type: string;
            required: boolean;
            description?: string;
        }> | null;
        serverType: 'local' | 'remote' | 'builtin';
        serverUrl: string | null;
        docsUrl: string | null;
        clientSecretId: string | null;
        localConfigSecretId: string | null;
        localConfig: {
            command?: string;
            arguments?: Array<string>;
            environment?: Array<{
                key: string;
                type: 'plain_text' | 'secret' | 'boolean' | 'number';
                value?: string;
                promptOnInstallation: boolean;
                required?: boolean;
                description?: string;
                default?: string | number | boolean;
                mounted?: boolean;
            }>;
            dockerImage?: string;
            serviceAccount?: string;
            transportType?: 'stdio' | 'streamable-http';
            httpPort?: number;
            httpPath?: string;
            nodePort?: number;
        } | null;
        deploymentSpecYaml: string | null;
        userConfig: {
            [key: string]: {
                type: 'string' | 'number' | 'boolean' | 'directory' | 'file';
                title: string;
                description: string;
                required?: boolean;
                default?: string | number | boolean | Array<string>;
                multiple?: boolean;
                sensitive?: boolean;
                min?: number;
                max?: number;
            };
        } | null;
        oauthConfig: {
            name: string;
            server_url: string;
            auth_server_url?: string;
            resource_metadata_url?: string;
            client_id: string;
            client_secret?: string;
            redirect_uris: Array<string>;
            scopes: Array<string>;
            description?: string;
            well_known_url?: string;
            default_scopes: Array<string>;
            supports_resource_metadata: boolean;
            generic_oauth?: boolean;
            token_endpoint?: string;
            access_token_env_var?: string;
            requires_proxy?: boolean;
            provider_name?: string;
            browser_auth?: boolean;
            streamable_http_url?: string;
            streamable_http_port?: number;
        } | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateInternalMcpCatalogItemResponse = UpdateInternalMcpCatalogItemResponses[keyof UpdateInternalMcpCatalogItemResponses];

export type GetInternalMcpCatalogToolsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}/tools';
};

export type GetInternalMcpCatalogToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetInternalMcpCatalogToolsError = GetInternalMcpCatalogToolsErrors[keyof GetInternalMcpCatalogToolsErrors];

export type GetInternalMcpCatalogToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        description: string | null;
        parameters: {
            [key: string]: unknown;
        };
        createdAt: string;
        assignedAgentCount: number;
        assignedAgents: Array<{
            id: string;
            name: string;
        }>;
    }>;
};

export type GetInternalMcpCatalogToolsResponse = GetInternalMcpCatalogToolsResponses[keyof GetInternalMcpCatalogToolsResponses];

export type DeleteInternalMcpCatalogItemByNameData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/by-name/{name}';
};

export type DeleteInternalMcpCatalogItemByNameErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteInternalMcpCatalogItemByNameError = DeleteInternalMcpCatalogItemByNameErrors[keyof DeleteInternalMcpCatalogItemByNameErrors];

export type DeleteInternalMcpCatalogItemByNameResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteInternalMcpCatalogItemByNameResponse = DeleteInternalMcpCatalogItemByNameResponses[keyof DeleteInternalMcpCatalogItemByNameResponses];

export type GetDeploymentYamlPreviewData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}/deployment-yaml-preview';
};

export type GetDeploymentYamlPreviewErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetDeploymentYamlPreviewError = GetDeploymentYamlPreviewErrors[keyof GetDeploymentYamlPreviewErrors];

export type GetDeploymentYamlPreviewResponses = {
    /**
     * Default Response
     */
    200: {
        yaml: string;
    };
};

export type GetDeploymentYamlPreviewResponse = GetDeploymentYamlPreviewResponses[keyof GetDeploymentYamlPreviewResponses];

export type ValidateDeploymentYamlData = {
    body: {
        yaml: string;
    };
    path?: never;
    query?: never;
    url: '/api/internal_mcp_catalog/validate-deployment-yaml';
};

export type ValidateDeploymentYamlErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ValidateDeploymentYamlError = ValidateDeploymentYamlErrors[keyof ValidateDeploymentYamlErrors];

export type ValidateDeploymentYamlResponses = {
    /**
     * Default Response
     */
    200: {
        valid: boolean;
        errors: Array<string>;
        warnings: Array<string>;
    };
};

export type ValidateDeploymentYamlResponse = ValidateDeploymentYamlResponses[keyof ValidateDeploymentYamlResponses];

export type ResetDeploymentYamlData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/internal_mcp_catalog/{id}/reset-deployment-yaml';
};

export type ResetDeploymentYamlErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ResetDeploymentYamlError = ResetDeploymentYamlErrors[keyof ResetDeploymentYamlErrors];

export type ResetDeploymentYamlResponses = {
    /**
     * Default Response
     */
    200: {
        yaml: string;
    };
};

export type ResetDeploymentYamlResponse = ResetDeploymentYamlResponses[keyof ResetDeploymentYamlResponses];

export type CheckInvitationData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/invitation/{id}/check';
};

export type CheckInvitationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CheckInvitationError = CheckInvitationErrors[keyof CheckInvitationErrors];

export type CheckInvitationResponses = {
    /**
     * Default Response
     */
    200: {
        invitation: {
            id: string;
            email: string;
            organizationId: string;
            status: 'pending' | 'accepted' | 'canceled';
            expiresAt: string | null;
        };
        userExists: boolean;
    };
};

export type CheckInvitationResponse = CheckInvitationResponses[keyof CheckInvitationResponses];

export type GetLimitsData = {
    body?: never;
    path?: never;
    query?: {
        entityType?: 'organization' | 'team' | 'agent';
        entityId?: string;
        limitType?: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
    };
    url: '/api/limits';
};

export type GetLimitsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetLimitsError = GetLimitsErrors[keyof GetLimitsErrors];

export type GetLimitsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        limitType: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue: number;
        mcpServerName: string | null;
        toolName: string | null;
        model?: Array<string> | null;
        lastCleanup: string | null;
        createdAt: string;
        updatedAt: string;
        modelUsage?: Array<{
            model: string;
            tokensIn: number;
            tokensOut: number;
            cost: number;
        }>;
    }>;
};

export type GetLimitsResponse = GetLimitsResponses[keyof GetLimitsResponses];

export type CreateLimitData = {
    body: {
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        limitType: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue: number;
        mcpServerName?: string | null;
        toolName?: string | null;
        model?: Array<string> | null;
        lastCleanup?: unknown;
    };
    path?: never;
    query?: never;
    url: '/api/limits';
};

export type CreateLimitErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateLimitError = CreateLimitErrors[keyof CreateLimitErrors];

export type CreateLimitResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        limitType: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue: number;
        mcpServerName: string | null;
        toolName: string | null;
        model?: Array<string> | null;
        lastCleanup: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateLimitResponse = CreateLimitResponses[keyof CreateLimitResponses];

export type DeleteLimitData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/limits/{id}';
};

export type DeleteLimitErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteLimitError = DeleteLimitErrors[keyof DeleteLimitErrors];

export type DeleteLimitResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteLimitResponse = DeleteLimitResponses[keyof DeleteLimitResponses];

export type GetLimitData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/limits/{id}';
};

export type GetLimitErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetLimitError = GetLimitErrors[keyof GetLimitErrors];

export type GetLimitResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        limitType: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue: number;
        mcpServerName: string | null;
        toolName: string | null;
        model?: Array<string> | null;
        lastCleanup: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetLimitResponse = GetLimitResponses[keyof GetLimitResponses];

export type UpdateLimitData = {
    body?: {
        entityType?: 'organization' | 'team' | 'agent';
        entityId?: string;
        limitType?: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue?: number;
        mcpServerName?: string | null;
        toolName?: string | null;
        model?: Array<string> | null;
        lastCleanup?: unknown;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/limits/{id}';
};

export type UpdateLimitErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateLimitError = UpdateLimitErrors[keyof UpdateLimitErrors];

export type UpdateLimitResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        limitType: 'token_cost' | 'mcp_server_calls' | 'tool_calls';
        limitValue: number;
        mcpServerName: string | null;
        toolName: string | null;
        model?: Array<string> | null;
        lastCleanup: string | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateLimitResponse = UpdateLimitResponses[keyof UpdateLimitResponses];

export type GetV1McpByProfileIdData = {
    body?: never;
    path: {
        profileId: string;
    };
    query?: never;
    url: '/v1/mcp/{profileId}';
};

export type GetV1McpByProfileIdErrors = {
    /**
     * Default Response
     */
    401: {
        error: string;
        message: string;
    };
};

export type GetV1McpByProfileIdError = GetV1McpByProfileIdErrors[keyof GetV1McpByProfileIdErrors];

export type GetV1McpByProfileIdResponses = {
    /**
     * Default Response
     */
    200: {
        name: string;
        version: string;
        agentId: string;
        transport: string;
        capabilities: {
            tools: boolean;
        };
        tokenAuth?: {
            tokenId: string;
            teamId: string | null;
            isOrganizationToken: boolean;
            isUserToken?: boolean;
            userId?: string;
        };
    };
};

export type GetV1McpByProfileIdResponse = GetV1McpByProfileIdResponses[keyof GetV1McpByProfileIdResponses];

export type PostV1McpByProfileIdData = {
    body?: {
        [key: string]: unknown;
    };
    path: {
        profileId: string;
    };
    query?: never;
    url: '/v1/mcp/{profileId}';
};

export type PostV1McpByProfileIdResponses = {
    /**
     * Default Response
     */
    200: unknown;
};

export type GetMcpServerInstallationRequestsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by status
         */
        status?: 'pending' | 'approved' | 'declined';
    };
    url: '/api/mcp_server_installation_requests';
};

export type GetMcpServerInstallationRequestsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServerInstallationRequestsError = GetMcpServerInstallationRequestsErrors[keyof GetMcpServerInstallationRequestsErrors];

export type GetMcpServerInstallationRequestsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetMcpServerInstallationRequestsResponse = GetMcpServerInstallationRequestsResponses[keyof GetMcpServerInstallationRequestsResponses];

export type CreateMcpServerInstallationRequestData = {
    body: {
        externalCatalogId?: string | null;
        requestReason?: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
    };
    path?: never;
    query?: never;
    url: '/api/mcp_server_installation_requests';
};

export type CreateMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateMcpServerInstallationRequestError = CreateMcpServerInstallationRequestErrors[keyof CreateMcpServerInstallationRequestErrors];

export type CreateMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateMcpServerInstallationRequestResponse = CreateMcpServerInstallationRequestResponses[keyof CreateMcpServerInstallationRequestResponses];

export type DeleteMcpServerInstallationRequestData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}';
};

export type DeleteMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteMcpServerInstallationRequestError = DeleteMcpServerInstallationRequestErrors[keyof DeleteMcpServerInstallationRequestErrors];

export type DeleteMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteMcpServerInstallationRequestResponse = DeleteMcpServerInstallationRequestResponses[keyof DeleteMcpServerInstallationRequestResponses];

export type GetMcpServerInstallationRequestData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}';
};

export type GetMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServerInstallationRequestError = GetMcpServerInstallationRequestErrors[keyof GetMcpServerInstallationRequestErrors];

export type GetMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetMcpServerInstallationRequestResponse = GetMcpServerInstallationRequestResponses[keyof GetMcpServerInstallationRequestResponses];

export type UpdateMcpServerInstallationRequestData = {
    body?: {
        status?: 'pending' | 'approved' | 'declined';
        requestReason?: string | null;
        customServerConfig?: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse?: string | null;
        reviewedBy?: string | null;
        reviewedAt?: unknown;
        notes?: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}';
};

export type UpdateMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateMcpServerInstallationRequestError = UpdateMcpServerInstallationRequestErrors[keyof UpdateMcpServerInstallationRequestErrors];

export type UpdateMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateMcpServerInstallationRequestResponse = UpdateMcpServerInstallationRequestResponses[keyof UpdateMcpServerInstallationRequestResponses];

export type ApproveMcpServerInstallationRequestData = {
    body?: {
        adminResponse?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}/approve';
};

export type ApproveMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ApproveMcpServerInstallationRequestError = ApproveMcpServerInstallationRequestErrors[keyof ApproveMcpServerInstallationRequestErrors];

export type ApproveMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type ApproveMcpServerInstallationRequestResponse = ApproveMcpServerInstallationRequestResponses[keyof ApproveMcpServerInstallationRequestResponses];

export type DeclineMcpServerInstallationRequestData = {
    body?: {
        adminResponse?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}/decline';
};

export type DeclineMcpServerInstallationRequestErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeclineMcpServerInstallationRequestError = DeclineMcpServerInstallationRequestErrors[keyof DeclineMcpServerInstallationRequestErrors];

export type DeclineMcpServerInstallationRequestResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type DeclineMcpServerInstallationRequestResponse = DeclineMcpServerInstallationRequestResponses[keyof DeclineMcpServerInstallationRequestResponses];

export type AddMcpServerInstallationRequestNoteData = {
    body: {
        content: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server_installation_requests/{id}/notes';
};

export type AddMcpServerInstallationRequestNoteErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AddMcpServerInstallationRequestNoteError = AddMcpServerInstallationRequestNoteErrors[keyof AddMcpServerInstallationRequestNoteErrors];

export type AddMcpServerInstallationRequestNoteResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        externalCatalogId: string | null;
        requestedBy: string;
        status: string;
        requestReason: string | null;
        customServerConfig: {
            type: 'remote';
            label: string;
            name: string;
            version?: string;
            serverType: string;
            serverUrl?: string;
            docsUrl?: string;
            userConfig?: {
                [key: string]: unknown;
            };
            oauthConfig?: {
                name: string;
                server_url: string;
                auth_server_url?: string;
                resource_metadata_url?: string;
                client_id: string;
                client_secret?: string;
                redirect_uris: Array<string>;
                scopes: Array<string>;
                description?: string;
                well_known_url?: string;
                default_scopes: Array<string>;
                supports_resource_metadata: boolean;
                generic_oauth?: boolean;
                token_endpoint?: string;
                access_token_env_var?: string;
                requires_proxy?: boolean;
                provider_name?: string;
                browser_auth?: boolean;
                streamable_http_url?: string;
                streamable_http_port?: number;
            };
        } | {
            type: 'local';
            label: string;
            name: string;
            version?: string;
            serverType: 'local';
            localConfig: {
                command?: string;
                arguments?: Array<string>;
                environment?: Array<{
                    key: string;
                    type: 'plain_text' | 'secret' | 'boolean' | 'number';
                    value?: string;
                    promptOnInstallation: boolean;
                    required?: boolean;
                    description?: string;
                    default?: string | number | boolean;
                    mounted?: boolean;
                }>;
                dockerImage?: string;
                transportType?: 'stdio' | 'streamable-http';
                httpPort?: number;
                httpPath?: string;
                nodePort?: number;
                serviceAccount?: string;
            };
        } | null;
        adminResponse: string | null;
        reviewedBy: string | null;
        reviewedAt: string | null;
        notes: Array<{
            id: string;
            userId: string;
            userName: string;
            content: string;
            createdAt: string;
        }> | null;
        createdAt: string;
        updatedAt: string;
    };
};

export type AddMcpServerInstallationRequestNoteResponse = AddMcpServerInstallationRequestNoteResponses[keyof AddMcpServerInstallationRequestNoteResponses];

export type GetMcpServersData = {
    body?: never;
    path?: never;
    query?: {
        catalogId?: string;
    };
    url: '/api/mcp_server';
};

export type GetMcpServersErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServersError = GetMcpServersErrors[keyof GetMcpServersErrors];

export type GetMcpServersResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        catalogId: string;
        serverType: 'local' | 'remote' | 'builtin';
        secretId: string | null;
        ownerId: string | null;
        teamId: string | null;
        reinstallRequired: boolean;
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
        oauthRefreshError: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt: string | null;
        createdAt: string;
        updatedAt: string;
        ownerEmail?: string | null;
        catalogName?: string | null;
        users?: Array<string>;
        userDetails?: Array<{
            userId: string;
            email: string;
            createdAt: string;
        }>;
        teamDetails?: {
            teamId: string;
            name: string;
            createdAt: string;
        } | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
    }>;
};

export type GetMcpServersResponse = GetMcpServersResponses[keyof GetMcpServersResponses];

export type InstallMcpServerData = {
    body: {
        name: string;
        catalogId: string;
        secretId?: string;
        ownerId?: string | null;
        teamId?: string | null;
        reinstallRequired?: boolean;
        localInstallationStatus?: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError?: string | null;
        oauthRefreshError?: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt?: unknown;
        userId?: string;
        userConfigValues?: {
            [key: string]: string;
        };
        environmentValues?: {
            [key: string]: string;
        };
        agentIds?: Array<string>;
        accessToken?: string;
        isByosVault?: boolean;
        serviceAccount?: string;
    };
    path?: never;
    query?: never;
    url: '/api/mcp_server';
};

export type InstallMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type InstallMcpServerError = InstallMcpServerErrors[keyof InstallMcpServerErrors];

export type InstallMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string;
        serverType: 'local' | 'remote' | 'builtin';
        secretId: string | null;
        ownerId: string | null;
        teamId: string | null;
        reinstallRequired: boolean;
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
        oauthRefreshError: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt: string | null;
        createdAt: string;
        updatedAt: string;
        ownerEmail?: string | null;
        catalogName?: string | null;
        users?: Array<string>;
        userDetails?: Array<{
            userId: string;
            email: string;
            createdAt: string;
        }>;
        teamDetails?: {
            teamId: string;
            name: string;
            createdAt: string;
        } | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
    };
};

export type InstallMcpServerResponse = InstallMcpServerResponses[keyof InstallMcpServerResponses];

export type DeleteMcpServerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}';
};

export type DeleteMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteMcpServerError = DeleteMcpServerErrors[keyof DeleteMcpServerErrors];

export type DeleteMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteMcpServerResponse = DeleteMcpServerResponses[keyof DeleteMcpServerResponses];

export type GetMcpServerData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}';
};

export type GetMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServerError = GetMcpServerErrors[keyof GetMcpServerErrors];

export type GetMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string;
        serverType: 'local' | 'remote' | 'builtin';
        secretId: string | null;
        ownerId: string | null;
        teamId: string | null;
        reinstallRequired: boolean;
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
        oauthRefreshError: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt: string | null;
        createdAt: string;
        updatedAt: string;
        ownerEmail?: string | null;
        catalogName?: string | null;
        users?: Array<string>;
        userDetails?: Array<{
            userId: string;
            email: string;
            createdAt: string;
        }>;
        teamDetails?: {
            teamId: string;
            name: string;
            createdAt: string;
        } | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
    };
};

export type GetMcpServerResponse = GetMcpServerResponses[keyof GetMcpServerResponses];

export type ReauthenticateMcpServerData = {
    body: {
        secretId: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}/reauthenticate';
};

export type ReauthenticateMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ReauthenticateMcpServerError = ReauthenticateMcpServerErrors[keyof ReauthenticateMcpServerErrors];

export type ReauthenticateMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string;
        serverType: 'local' | 'remote' | 'builtin';
        secretId: string | null;
        ownerId: string | null;
        teamId: string | null;
        reinstallRequired: boolean;
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
        oauthRefreshError: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt: string | null;
        createdAt: string;
        updatedAt: string;
        ownerEmail?: string | null;
        catalogName?: string | null;
        users?: Array<string>;
        userDetails?: Array<{
            userId: string;
            email: string;
            createdAt: string;
        }>;
        teamDetails?: {
            teamId: string;
            name: string;
            createdAt: string;
        } | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
    };
};

export type ReauthenticateMcpServerResponse = ReauthenticateMcpServerResponses[keyof ReauthenticateMcpServerResponses];

export type GetMcpServerInstallationStatusData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}/installation-status';
};

export type GetMcpServerInstallationStatusErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServerInstallationStatusError = GetMcpServerInstallationStatusErrors[keyof GetMcpServerInstallationStatusErrors];

export type GetMcpServerInstallationStatusResponses = {
    /**
     * Default Response
     */
    200: {
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
    };
};

export type GetMcpServerInstallationStatusResponse = GetMcpServerInstallationStatusResponses[keyof GetMcpServerInstallationStatusResponses];

export type GetMcpServerToolsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}/tools';
};

export type GetMcpServerToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpServerToolsError = GetMcpServerToolsErrors[keyof GetMcpServerToolsErrors];

export type GetMcpServerToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        description: string | null;
        parameters: {
            [key: string]: unknown;
        };
        createdAt: string;
        assignedAgentCount: number;
        assignedAgents: Array<{
            id: string;
            name: string;
        }>;
    }>;
};

export type GetMcpServerToolsResponse = GetMcpServerToolsResponses[keyof GetMcpServerToolsResponses];

export type ReinstallMcpServerData = {
    body?: {
        environmentValues?: {
            [key: string]: string;
        };
        isByosVault?: boolean;
        serviceAccount?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/mcp_server/{id}/reinstall';
};

export type ReinstallMcpServerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ReinstallMcpServerError = ReinstallMcpServerErrors[keyof ReinstallMcpServerErrors];

export type ReinstallMcpServerResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        catalogId: string;
        serverType: 'local' | 'remote' | 'builtin';
        secretId: string | null;
        ownerId: string | null;
        teamId: string | null;
        reinstallRequired: boolean;
        localInstallationStatus: 'idle' | 'pending' | 'discovering-tools' | 'success' | 'error';
        localInstallationError: string | null;
        oauthRefreshError: 'refresh_failed' | 'no_refresh_token';
        oauthRefreshFailedAt: string | null;
        createdAt: string;
        updatedAt: string;
        ownerEmail?: string | null;
        catalogName?: string | null;
        users?: Array<string>;
        userDetails?: Array<{
            userId: string;
            email: string;
            createdAt: string;
        }>;
        teamDetails?: {
            teamId: string;
            name: string;
            createdAt: string;
        } | null;
        secretStorageType?: 'vault' | 'external_vault' | 'database' | 'none';
    };
};

export type ReinstallMcpServerResponse = ReinstallMcpServerResponses[keyof ReinstallMcpServerResponses];

export type GetMcpToolCallsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by agent ID
         */
        agentId?: string;
        /**
         * Filter by start date (ISO 8601 format)
         */
        startDate?: string;
        /**
         * Filter by end date (ISO 8601 format)
         */
        endDate?: string;
        /**
         * Free-text search across MCP server name, tool name, and arguments (case-insensitive)
         */
        search?: string;
        limit?: number;
        offset?: number;
        sortBy?: 'createdAt' | 'agentId' | 'mcpServerName' | 'method';
        sortDirection?: 'asc' | 'desc';
    };
    url: '/api/mcp-tool-calls';
};

export type GetMcpToolCallsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpToolCallsError = GetMcpToolCallsErrors[keyof GetMcpToolCallsErrors];

export type GetMcpToolCallsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            agentId: string;
            mcpServerName: string;
            method: string;
            /**
             * Represents a tool call in a provider-agnostic way
             */
            toolCall: {
                id: string;
                name: string;
                arguments: {
                    [key: string]: unknown;
                };
            } | null;
            toolResult: unknown;
            userId: string | null;
            authMethod: 'oauth' | 'user_token' | 'org_token' | 'team_token' | 'external_idp';
            createdAt: string;
            userName: string | null;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetMcpToolCallsResponse = GetMcpToolCallsResponses[keyof GetMcpToolCallsResponses];

export type GetMcpToolCallData = {
    body?: never;
    path: {
        mcpToolCallId: string;
    };
    query?: never;
    url: '/api/mcp-tool-calls/{mcpToolCallId}';
};

export type GetMcpToolCallErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetMcpToolCallError = GetMcpToolCallErrors[keyof GetMcpToolCallErrors];

export type GetMcpToolCallResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        agentId: string;
        mcpServerName: string;
        method: string;
        /**
         * Represents a tool call in a provider-agnostic way
         */
        toolCall: {
            id: string;
            name: string;
            arguments: {
                [key: string]: unknown;
            };
        } | null;
        toolResult: unknown;
        userId: string | null;
        authMethod: 'oauth' | 'user_token' | 'org_token' | 'team_token' | 'external_idp';
        createdAt: string;
        userName: string | null;
    };
};

export type GetMcpToolCallResponse = GetMcpToolCallResponses[keyof GetMcpToolCallResponses];

export type MistralChatCompletionsWithDefaultAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v1/mistral/chat/completions';
};

export type MistralChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type MistralChatCompletionsWithDefaultAgentError = MistralChatCompletionsWithDefaultAgentErrors[keyof MistralChatCompletionsWithDefaultAgentErrors];

export type MistralChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: MistralChatCompletionResponse;
};

export type MistralChatCompletionsWithDefaultAgentResponse = MistralChatCompletionsWithDefaultAgentResponses[keyof MistralChatCompletionsWithDefaultAgentResponses];

export type MistralChatCompletionsWithAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/mistral/{agentId}/chat/completions';
};

export type MistralChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type MistralChatCompletionsWithAgentError = MistralChatCompletionsWithAgentErrors[keyof MistralChatCompletionsWithAgentErrors];

export type MistralChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: MistralChatCompletionResponse;
};

export type MistralChatCompletionsWithAgentResponse = MistralChatCompletionsWithAgentResponses[keyof MistralChatCompletionsWithAgentResponses];

export type InitiateOAuthData = {
    body: {
        catalogId: string;
        serverId?: string;
    };
    path?: never;
    query?: never;
    url: '/api/oauth/initiate';
};

export type InitiateOAuthErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type InitiateOAuthError = InitiateOAuthErrors[keyof InitiateOAuthErrors];

export type InitiateOAuthResponses = {
    /**
     * Default Response
     */
    200: {
        authorizationUrl: string;
        state: string;
    };
};

export type InitiateOAuthResponse = InitiateOAuthResponses[keyof InitiateOAuthResponses];

export type HandleOAuthCallbackData = {
    body: {
        code: string;
        state: string;
    };
    path?: never;
    query?: never;
    url: '/api/oauth/callback';
};

export type HandleOAuthCallbackErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type HandleOAuthCallbackError = HandleOAuthCallbackErrors[keyof HandleOAuthCallbackErrors];

export type HandleOAuthCallbackResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
        catalogId: string;
        name: string;
        accessToken: string;
        refreshToken?: string;
        expiresIn?: number;
        secretId: string;
    };
};

export type HandleOAuthCallbackResponse = HandleOAuthCallbackResponses[keyof HandleOAuthCallbackResponses];

export type GetWellKnownOauthProtectedResourceBy__Data = {
    body?: never;
    path: {
        '*': string;
    };
    query?: never;
    url: '/.well-known/oauth-protected-resource/{*}';
};

export type GetWellKnownOauthProtectedResourceBy__Responses = {
    /**
     * Default Response
     */
    200: {
        resource: string;
        authorization_servers: Array<string>;
        scopes_supported: Array<string>;
        bearer_methods_supported: Array<string>;
    };
};

export type GetWellKnownOauthProtectedResourceBy__Response = GetWellKnownOauthProtectedResourceBy__Responses[keyof GetWellKnownOauthProtectedResourceBy__Responses];

export type GetWellKnownOauthAuthorizationServerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/.well-known/oauth-authorization-server';
};

export type GetWellKnownOauthAuthorizationServerResponses = {
    /**
     * Default Response
     */
    200: {
        issuer: string;
        authorization_endpoint: string;
        token_endpoint: string;
        registration_endpoint: string;
        jwks_uri: string;
        response_types_supported: Array<string>;
        grant_types_supported: Array<string>;
        token_endpoint_auth_methods_supported: Array<string>;
        code_challenge_methods_supported: Array<string>;
        scopes_supported: Array<string>;
        client_id_metadata_document_supported: boolean;
    };
};

export type GetWellKnownOauthAuthorizationServerResponse = GetWellKnownOauthAuthorizationServerResponses[keyof GetWellKnownOauthAuthorizationServerResponses];

export type OllamaChatCompletionsWithDefaultAgentData = {
    body?: OllamaChatCompletionRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for Ollama (typically not required)
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/ollama/chat/completions';
};

export type OllamaChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type OllamaChatCompletionsWithDefaultAgentError = OllamaChatCompletionsWithDefaultAgentErrors[keyof OllamaChatCompletionsWithDefaultAgentErrors];

export type OllamaChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: OllamaChatCompletionResponse;
};

export type OllamaChatCompletionsWithDefaultAgentResponse = OllamaChatCompletionsWithDefaultAgentResponses[keyof OllamaChatCompletionsWithDefaultAgentResponses];

export type OllamaChatCompletionsWithAgentData = {
    body?: OllamaChatCompletionRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for Ollama (typically not required)
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/ollama/{agentId}/chat/completions';
};

export type OllamaChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type OllamaChatCompletionsWithAgentError = OllamaChatCompletionsWithAgentErrors[keyof OllamaChatCompletionsWithAgentErrors];

export type OllamaChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: OllamaChatCompletionResponse;
};

export type OllamaChatCompletionsWithAgentResponse = OllamaChatCompletionsWithAgentResponses[keyof OllamaChatCompletionsWithAgentResponses];

export type OpenAiChatCompletionsWithDefaultAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path?: never;
    query?: never;
    url: '/v1/openai/chat/completions';
};

export type OpenAiChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type OpenAiChatCompletionsWithDefaultAgentError = OpenAiChatCompletionsWithDefaultAgentErrors[keyof OpenAiChatCompletionsWithDefaultAgentErrors];

export type OpenAiChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: OpenAiChatCompletionResponse;
};

export type OpenAiChatCompletionsWithDefaultAgentResponse = OpenAiChatCompletionsWithDefaultAgentResponses[keyof OpenAiChatCompletionsWithDefaultAgentResponses];

export type OpenAiChatCompletionsWithAgentData = {
    body?: MistralChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for OpenAI
         */
        authorization: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/openai/{agentId}/chat/completions';
};

export type OpenAiChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type OpenAiChatCompletionsWithAgentError = OpenAiChatCompletionsWithAgentErrors[keyof OpenAiChatCompletionsWithAgentErrors];

export type OpenAiChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: OpenAiChatCompletionResponse;
};

export type OpenAiChatCompletionsWithAgentResponse = OpenAiChatCompletionsWithAgentResponses[keyof OpenAiChatCompletionsWithAgentResponses];

export type GetOptimizationRulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/optimization-rules';
};

export type GetOptimizationRulesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetOptimizationRulesError = GetOptimizationRulesErrors[keyof GetOptimizationRulesErrors];

export type GetOptimizationRulesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        conditions: Array<{
            maxLength: number;
        } | {
            hasTools: boolean;
        }>;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        targetModel: string;
        enabled: boolean;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetOptimizationRulesResponse = GetOptimizationRulesResponses[keyof GetOptimizationRulesResponses];

export type CreateOptimizationRuleData = {
    body: {
        id?: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        conditions: Array<{
            maxLength: number;
        } | {
            hasTools: boolean;
        }>;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        targetModel: string;
        enabled?: boolean;
        createdAt?: unknown;
        updatedAt?: unknown;
    };
    path?: never;
    query?: never;
    url: '/api/optimization-rules';
};

export type CreateOptimizationRuleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateOptimizationRuleError = CreateOptimizationRuleErrors[keyof CreateOptimizationRuleErrors];

export type CreateOptimizationRuleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        conditions: Array<{
            maxLength: number;
        } | {
            hasTools: boolean;
        }>;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        targetModel: string;
        enabled: boolean;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateOptimizationRuleResponse = CreateOptimizationRuleResponses[keyof CreateOptimizationRuleResponses];

export type DeleteOptimizationRuleData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/optimization-rules/{id}';
};

export type DeleteOptimizationRuleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteOptimizationRuleError = DeleteOptimizationRuleErrors[keyof DeleteOptimizationRuleErrors];

export type DeleteOptimizationRuleResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteOptimizationRuleResponse = DeleteOptimizationRuleResponses[keyof DeleteOptimizationRuleResponses];

export type UpdateOptimizationRuleData = {
    body?: {
        id?: string;
        entityType?: 'organization' | 'team' | 'agent';
        entityId?: string;
        conditions?: Array<{
            maxLength: number;
        } | {
            hasTools: boolean;
        }>;
        provider?: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        targetModel?: string;
        enabled?: boolean;
        createdAt?: unknown;
        updatedAt?: unknown;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/optimization-rules/{id}';
};

export type UpdateOptimizationRuleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateOptimizationRuleError = UpdateOptimizationRuleErrors[keyof UpdateOptimizationRuleErrors];

export type UpdateOptimizationRuleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        entityType: 'organization' | 'team' | 'agent';
        entityId: string;
        conditions: Array<{
            maxLength: number;
        } | {
            hasTools: boolean;
        }>;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        targetModel: string;
        enabled: boolean;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateOptimizationRuleResponse = UpdateOptimizationRuleResponses[keyof UpdateOptimizationRuleResponses];

export type GetRolesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/roles';
};

export type GetRolesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetRolesError = GetRolesErrors[keyof GetRolesErrors];

export type GetRolesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        organizationId?: string;
        role: string;
        name: string;
        permission: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
        createdAt: string;
        updatedAt: string | null;
        predefined: boolean;
    }>;
};

export type GetRolesResponse = GetRolesResponses[keyof GetRolesResponses];

export type CreateRoleData = {
    body: {
        name: string;
        permission: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
    };
    path?: never;
    query?: never;
    url: '/api/roles';
};

export type CreateRoleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateRoleError = CreateRoleErrors[keyof CreateRoleErrors];

export type CreateRoleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId?: string;
        role: string;
        name: string;
        permission: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
        createdAt: string;
        updatedAt: string | null;
        predefined: boolean;
    };
};

export type CreateRoleResponse = CreateRoleResponses[keyof CreateRoleResponses];

export type DeleteRoleData = {
    body?: never;
    path: {
        /**
         * Custom role ID (base62)
         */
        roleId: string;
    };
    query?: never;
    url: '/api/roles/{roleId}';
};

export type DeleteRoleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteRoleError = DeleteRoleErrors[keyof DeleteRoleErrors];

export type DeleteRoleResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteRoleResponse = DeleteRoleResponses[keyof DeleteRoleResponses];

export type GetRoleData = {
    body?: never;
    path: {
        /**
         * Predefined role name or custom role ID
         */
        roleId: 'admin' | 'editor' | 'member' | string;
    };
    query?: never;
    url: '/api/roles/{roleId}';
};

export type GetRoleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetRoleError = GetRoleErrors[keyof GetRoleErrors];

export type GetRoleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId?: string;
        role: string;
        name: string;
        permission: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
        createdAt: string;
        updatedAt: string | null;
        predefined: boolean;
    };
};

export type GetRoleResponse = GetRoleResponses[keyof GetRoleResponses];

export type UpdateRoleData = {
    body?: {
        name?: string;
        permission?: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
    };
    path: {
        /**
         * Predefined role name or custom role ID
         */
        roleId: 'admin' | 'editor' | 'member' | string;
    };
    query?: never;
    url: '/api/roles/{roleId}';
};

export type UpdateRoleErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateRoleError = UpdateRoleErrors[keyof UpdateRoleErrors];

export type UpdateRoleResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        organizationId?: string;
        role: string;
        name: string;
        permission: {
            [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
        };
        createdAt: string;
        updatedAt: string | null;
        predefined: boolean;
    };
};

export type UpdateRoleResponse = UpdateRoleResponses[keyof UpdateRoleResponses];

export type GetOrganizationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/organization';
};

export type GetOrganizationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetOrganizationError = GetOrganizationErrors[keyof GetOrganizationErrors];

export type GetOrganizationResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        slug: string;
        logo: string | null;
        createdAt: string;
        metadata: string | null;
        limitCleanupInterval: '1h' | '12h' | '24h' | '1w' | '1m';
        onboardingComplete: boolean;
        theme: 'modern-minimal' | 'clean-slate' | 'mono' | 'twitter' | 'tangerine' | 'bubblegum' | 'caffeine' | 'amber-minimal' | 'cosmic-night' | 'doom-64' | 'mocha-mousse' | 'nature' | 'sunset-horizon' | 'neo-brutalism' | 'vercel' | 'claude' | 'vintage-paper' | 'boxy-minimalistic' | 'catppuccin' | 'solarized-dark' | 'gruvbox-dark' | 'dracula-dark' | 'monokai-dark' | 'moonlight-dark';
        customFont: 'lato' | 'inter' | 'open-sans' | 'roboto' | 'source-sans-pro' | 'jetbrains-mono';
        convertToolResultsToToon: boolean;
        compressionScope: 'organization' | 'team';
        autoConfigureNewTools: boolean;
        globalToolPolicy: 'permissive' | 'restrictive';
        allowChatFileUploads: boolean;
    };
};

export type GetOrganizationResponse = GetOrganizationResponses[keyof GetOrganizationResponses];

export type UpdateOrganizationData = {
    body?: {
        theme?: 'modern-minimal' | 'clean-slate' | 'mono' | 'twitter' | 'tangerine' | 'bubblegum' | 'caffeine' | 'amber-minimal' | 'cosmic-night' | 'doom-64' | 'mocha-mousse' | 'nature' | 'sunset-horizon' | 'neo-brutalism' | 'vercel' | 'claude' | 'vintage-paper' | 'boxy-minimalistic' | 'catppuccin' | 'solarized-dark' | 'gruvbox-dark' | 'dracula-dark' | 'monokai-dark' | 'moonlight-dark';
        customFont?: 'lato' | 'inter' | 'open-sans' | 'roboto' | 'source-sans-pro' | 'jetbrains-mono';
        limitCleanupInterval?: '1h' | '12h' | '24h' | '1w' | '1m';
        compressionScope?: 'organization' | 'team';
        globalToolPolicy?: 'permissive' | 'restrictive';
        logo?: string | null;
        onboardingComplete?: boolean;
        convertToolResultsToToon?: boolean;
        autoConfigureNewTools?: boolean;
        allowChatFileUploads?: boolean;
    };
    path?: never;
    query?: never;
    url: '/api/organization';
};

export type UpdateOrganizationErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateOrganizationError = UpdateOrganizationErrors[keyof UpdateOrganizationErrors];

export type UpdateOrganizationResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        slug: string;
        logo: string | null;
        createdAt: string;
        metadata: string | null;
        limitCleanupInterval: '1h' | '12h' | '24h' | '1w' | '1m';
        onboardingComplete: boolean;
        theme: 'modern-minimal' | 'clean-slate' | 'mono' | 'twitter' | 'tangerine' | 'bubblegum' | 'caffeine' | 'amber-minimal' | 'cosmic-night' | 'doom-64' | 'mocha-mousse' | 'nature' | 'sunset-horizon' | 'neo-brutalism' | 'vercel' | 'claude' | 'vintage-paper' | 'boxy-minimalistic' | 'catppuccin' | 'solarized-dark' | 'gruvbox-dark' | 'dracula-dark' | 'monokai-dark' | 'moonlight-dark';
        customFont: 'lato' | 'inter' | 'open-sans' | 'roboto' | 'source-sans-pro' | 'jetbrains-mono';
        convertToolResultsToToon: boolean;
        compressionScope: 'organization' | 'team';
        autoConfigureNewTools: boolean;
        globalToolPolicy: 'permissive' | 'restrictive';
        allowChatFileUploads: boolean;
    };
};

export type UpdateOrganizationResponse = UpdateOrganizationResponses[keyof UpdateOrganizationResponses];

export type GetOnboardingStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/organization/onboarding-status';
};

export type GetOnboardingStatusErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetOnboardingStatusError = GetOnboardingStatusErrors[keyof GetOnboardingStatusErrors];

export type GetOnboardingStatusResponses = {
    /**
     * Default Response
     */
    200: {
        hasLlmProxyLogs: boolean;
        hasMcpGatewayLogs: boolean;
    };
};

export type GetOnboardingStatusResponse = GetOnboardingStatusResponses[keyof GetOnboardingStatusResponses];

export type GetPublicAppearanceData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/organization/appearance';
};

export type GetPublicAppearanceErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetPublicAppearanceError = GetPublicAppearanceErrors[keyof GetPublicAppearanceErrors];

export type GetPublicAppearanceResponses = {
    /**
     * Default Response
     */
    200: {
        theme: 'modern-minimal' | 'clean-slate' | 'mono' | 'twitter' | 'tangerine' | 'bubblegum' | 'caffeine' | 'amber-minimal' | 'cosmic-night' | 'doom-64' | 'mocha-mousse' | 'nature' | 'sunset-horizon' | 'neo-brutalism' | 'vercel' | 'claude' | 'vintage-paper' | 'boxy-minimalistic' | 'catppuccin' | 'solarized-dark' | 'gruvbox-dark' | 'dracula-dark' | 'monokai-dark' | 'moonlight-dark';
        customFont: 'lato' | 'inter' | 'open-sans' | 'roboto' | 'source-sans-pro' | 'jetbrains-mono';
        logo: string | null;
    };
};

export type GetPublicAppearanceResponse = GetPublicAppearanceResponses[keyof GetPublicAppearanceResponses];

export type GetPolicyConfigSubagentPromptData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/policy-config-subagent/prompt';
};

export type GetPolicyConfigSubagentPromptErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetPolicyConfigSubagentPromptError = GetPolicyConfigSubagentPromptErrors[keyof GetPolicyConfigSubagentPromptErrors];

export type GetPolicyConfigSubagentPromptResponses = {
    /**
     * Default Response
     */
    200: {
        promptTemplate: string;
    };
};

export type GetPolicyConfigSubagentPromptResponse = GetPolicyConfigSubagentPromptResponses[keyof GetPolicyConfigSubagentPromptResponses];

export type GetSecretsTypeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/secrets/type';
};

export type GetSecretsTypeErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetSecretsTypeError = GetSecretsTypeErrors[keyof GetSecretsTypeErrors];

export type GetSecretsTypeResponses = {
    /**
     * Default Response
     */
    200: {
        type: 'DB' | 'Vault' | 'BYOS_VAULT';
        meta: {
            [key: string]: string;
        };
    };
};

export type GetSecretsTypeResponse = GetSecretsTypeResponses[keyof GetSecretsTypeResponses];

export type GetSecretData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/secrets/{id}';
};

export type GetSecretErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetSecretError = GetSecretErrors[keyof GetSecretErrors];

export type GetSecretResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        secret: {
            [key: string]: unknown;
        };
        isVault: boolean;
        isByosVault: boolean;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetSecretResponse = GetSecretResponses[keyof GetSecretResponses];

export type CheckSecretsConnectivityData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/secrets/check-connectivity';
};

export type CheckSecretsConnectivityErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CheckSecretsConnectivityError = CheckSecretsConnectivityErrors[keyof CheckSecretsConnectivityErrors];

export type CheckSecretsConnectivityResponses = {
    /**
     * Default Response
     */
    200: {
        secretCount: number;
    };
};

export type CheckSecretsConnectivityResponse = CheckSecretsConnectivityResponses[keyof CheckSecretsConnectivityResponses];

export type InitializeSecretsManagerData = {
    body: {
        type: 'DB' | 'Vault' | 'BYOS_VAULT';
    };
    path?: never;
    query?: never;
    url: '/api/secrets/initialize-secrets-manager';
};

export type InitializeSecretsManagerErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type InitializeSecretsManagerError = InitializeSecretsManagerErrors[keyof InitializeSecretsManagerErrors];

export type InitializeSecretsManagerResponses = {
    /**
     * Default Response
     */
    200: {
        type: 'DB' | 'Vault' | 'BYOS_VAULT';
        meta: {
            [key: string]: string;
        };
    };
};

export type InitializeSecretsManagerResponse = InitializeSecretsManagerResponses[keyof InitializeSecretsManagerResponses];

export type GetTeamStatisticsData = {
    body?: never;
    path?: never;
    query?: {
        timeframe?: '5m' | '15m' | '30m' | '1h' | '24h' | '7d' | '30d' | '90d' | '12m' | 'all' | string;
    };
    url: '/api/statistics/teams';
};

export type GetTeamStatisticsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamStatisticsError = GetTeamStatisticsErrors[keyof GetTeamStatisticsErrors];

export type GetTeamStatisticsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        teamId: string;
        teamName: string;
        members: number;
        agents: number;
        requests: number;
        inputTokens: number;
        outputTokens: number;
        cost: number;
        timeSeries: Array<{
            timestamp: string;
            value: number;
        }>;
    }>;
};

export type GetTeamStatisticsResponse = GetTeamStatisticsResponses[keyof GetTeamStatisticsResponses];

export type GetAgentStatisticsData = {
    body?: never;
    path?: never;
    query?: {
        timeframe?: '5m' | '15m' | '30m' | '1h' | '24h' | '7d' | '30d' | '90d' | '12m' | 'all' | string;
    };
    url: '/api/statistics/agents';
};

export type GetAgentStatisticsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetAgentStatisticsError = GetAgentStatisticsErrors[keyof GetAgentStatisticsErrors];

export type GetAgentStatisticsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        agentId: string;
        agentName: string;
        agentType: string;
        teamName: string;
        requests: number;
        inputTokens: number;
        outputTokens: number;
        cost: number;
        timeSeries: Array<{
            timestamp: string;
            value: number;
        }>;
    }>;
};

export type GetAgentStatisticsResponse = GetAgentStatisticsResponses[keyof GetAgentStatisticsResponses];

export type GetModelStatisticsData = {
    body?: never;
    path?: never;
    query?: {
        timeframe?: '5m' | '15m' | '30m' | '1h' | '24h' | '7d' | '30d' | '90d' | '12m' | 'all' | string;
    };
    url: '/api/statistics/models';
};

export type GetModelStatisticsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetModelStatisticsError = GetModelStatisticsErrors[keyof GetModelStatisticsErrors];

export type GetModelStatisticsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        model: string;
        requests: number;
        inputTokens: number;
        outputTokens: number;
        cost: number;
        percentage: number;
        timeSeries: Array<{
            timestamp: string;
            value: number;
        }>;
    }>;
};

export type GetModelStatisticsResponse = GetModelStatisticsResponses[keyof GetModelStatisticsResponses];

export type GetOverviewStatisticsData = {
    body?: never;
    path?: never;
    query?: {
        timeframe?: '5m' | '15m' | '30m' | '1h' | '24h' | '7d' | '30d' | '90d' | '12m' | 'all' | string;
    };
    url: '/api/statistics/overview';
};

export type GetOverviewStatisticsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetOverviewStatisticsError = GetOverviewStatisticsErrors[keyof GetOverviewStatisticsErrors];

export type GetOverviewStatisticsResponses = {
    /**
     * Default Response
     */
    200: {
        totalRequests: number;
        totalTokens: number;
        totalCost: number;
        topTeam: string;
        topAgent: string;
        topModel: string;
    };
};

export type GetOverviewStatisticsResponse = GetOverviewStatisticsResponses[keyof GetOverviewStatisticsResponses];

export type GetCostSavingsStatisticsData = {
    body?: never;
    path?: never;
    query?: {
        timeframe?: '5m' | '15m' | '30m' | '1h' | '24h' | '7d' | '30d' | '90d' | '12m' | 'all' | string;
    };
    url: '/api/statistics/cost-savings';
};

export type GetCostSavingsStatisticsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetCostSavingsStatisticsError = GetCostSavingsStatisticsErrors[keyof GetCostSavingsStatisticsErrors];

export type GetCostSavingsStatisticsResponses = {
    /**
     * Default Response
     */
    200: {
        totalBaselineCost: number;
        totalActualCost: number;
        totalSavings: number;
        totalOptimizationSavings: number;
        totalToonSavings: number;
        timeSeries: Array<{
            timestamp: string;
            baselineCost: number;
            actualCost: number;
            optimizationSavings: number;
            toonSavings: number;
        }>;
    };
};

export type GetCostSavingsStatisticsResponse = GetCostSavingsStatisticsResponses[keyof GetCostSavingsStatisticsResponses];

export type GetTeamsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/teams';
};

export type GetTeamsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamsError = GetTeamsErrors[keyof GetTeamsErrors];

export type GetTeamsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        name: string;
        description: string | null;
        organizationId: string;
        createdBy: string;
        createdAt: string;
        updatedAt: string;
        convertToolResultsToToon: boolean;
        members?: Array<{
            id: string;
            teamId: string;
            userId: string;
            role: string;
            syncedFromSso: boolean;
            createdAt: string;
        }>;
    }>;
};

export type GetTeamsResponse = GetTeamsResponses[keyof GetTeamsResponses];

export type CreateTeamData = {
    body: {
        name: string;
        description?: string;
    };
    path?: never;
    query?: never;
    url: '/api/teams';
};

export type CreateTeamErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateTeamError = CreateTeamErrors[keyof CreateTeamErrors];

export type CreateTeamResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        description: string | null;
        organizationId: string;
        createdBy: string;
        createdAt: string;
        updatedAt: string;
        convertToolResultsToToon: boolean;
        members?: Array<{
            id: string;
            teamId: string;
            userId: string;
            role: string;
            syncedFromSso: boolean;
            createdAt: string;
        }>;
    };
};

export type CreateTeamResponse = CreateTeamResponses[keyof CreateTeamResponses];

export type DeleteTeamData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}';
};

export type DeleteTeamErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteTeamError = DeleteTeamErrors[keyof DeleteTeamErrors];

export type DeleteTeamResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteTeamResponse = DeleteTeamResponses[keyof DeleteTeamResponses];

export type GetTeamData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}';
};

export type GetTeamErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamError = GetTeamErrors[keyof GetTeamErrors];

export type GetTeamResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        description: string | null;
        organizationId: string;
        createdBy: string;
        createdAt: string;
        updatedAt: string;
        convertToolResultsToToon: boolean;
        members?: Array<{
            id: string;
            teamId: string;
            userId: string;
            role: string;
            syncedFromSso: boolean;
            createdAt: string;
        }>;
    };
};

export type GetTeamResponse = GetTeamResponses[keyof GetTeamResponses];

export type UpdateTeamData = {
    body?: {
        name?: string;
        description?: string;
        convertToolResultsToToon?: boolean;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}';
};

export type UpdateTeamErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateTeamError = UpdateTeamErrors[keyof UpdateTeamErrors];

export type UpdateTeamResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        description: string | null;
        organizationId: string;
        createdBy: string;
        createdAt: string;
        updatedAt: string;
        convertToolResultsToToon: boolean;
        members?: Array<{
            id: string;
            teamId: string;
            userId: string;
            role: string;
            syncedFromSso: boolean;
            createdAt: string;
        }>;
    };
};

export type UpdateTeamResponse = UpdateTeamResponses[keyof UpdateTeamResponses];

export type GetTeamMembersData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}/members';
};

export type GetTeamMembersErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamMembersError = GetTeamMembersErrors[keyof GetTeamMembersErrors];

export type GetTeamMembersResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        teamId: string;
        userId: string;
        role: string;
        syncedFromSso: boolean;
        createdAt: string;
    }>;
};

export type GetTeamMembersResponse = GetTeamMembersResponses[keyof GetTeamMembersResponses];

export type AddTeamMemberData = {
    body: {
        userId: string;
        role?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}/members';
};

export type AddTeamMemberErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AddTeamMemberError = AddTeamMemberErrors[keyof AddTeamMemberErrors];

export type AddTeamMemberResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        teamId: string;
        userId: string;
        role: string;
        syncedFromSso: boolean;
        createdAt: string;
    };
};

export type AddTeamMemberResponse = AddTeamMemberResponses[keyof AddTeamMemberResponses];

export type RemoveTeamMemberData = {
    body?: never;
    path: {
        id: string;
        userId: string;
    };
    query?: never;
    url: '/api/teams/{id}/members/{userId}';
};

export type RemoveTeamMemberErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RemoveTeamMemberError = RemoveTeamMemberErrors[keyof RemoveTeamMemberErrors];

export type RemoveTeamMemberResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type RemoveTeamMemberResponse = RemoveTeamMemberResponses[keyof RemoveTeamMemberResponses];

export type GetTeamExternalGroupsData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}/external-groups';
};

export type GetTeamExternalGroupsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamExternalGroupsError = GetTeamExternalGroupsErrors[keyof GetTeamExternalGroupsErrors];

export type GetTeamExternalGroupsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        teamId: string;
        groupIdentifier: string;
        createdAt: string;
    }>;
};

export type GetTeamExternalGroupsResponse = GetTeamExternalGroupsResponses[keyof GetTeamExternalGroupsResponses];

export type AddTeamExternalGroupData = {
    body: {
        groupIdentifier: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/teams/{id}/external-groups';
};

export type AddTeamExternalGroupErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type AddTeamExternalGroupError = AddTeamExternalGroupErrors[keyof AddTeamExternalGroupErrors];

export type AddTeamExternalGroupResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        teamId: string;
        groupIdentifier: string;
        createdAt: string;
    };
};

export type AddTeamExternalGroupResponse = AddTeamExternalGroupResponses[keyof AddTeamExternalGroupResponses];

export type RemoveTeamExternalGroupData = {
    body?: never;
    path: {
        id: string;
        groupId: string;
    };
    query?: never;
    url: '/api/teams/{id}/external-groups/{groupId}';
};

export type RemoveTeamExternalGroupErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RemoveTeamExternalGroupError = RemoveTeamExternalGroupErrors[keyof RemoveTeamExternalGroupErrors];

export type RemoveTeamExternalGroupResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type RemoveTeamExternalGroupResponse = RemoveTeamExternalGroupResponses[keyof RemoveTeamExternalGroupResponses];

export type GetTokenPricesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/token-prices';
};

export type GetTokenPricesErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTokenPricesError = GetTokenPricesErrors[keyof GetTokenPricesErrors];

export type GetTokenPricesResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model: string;
        pricePerMillionInput: string;
        pricePerMillionOutput: string;
        createdAt: string;
        updatedAt: string;
    }>;
};

export type GetTokenPricesResponse = GetTokenPricesResponses[keyof GetTokenPricesResponses];

export type CreateTokenPriceData = {
    body: {
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model: string;
        pricePerMillionInput: string;
        pricePerMillionOutput: string;
    };
    path?: never;
    query?: never;
    url: '/api/token-prices';
};

export type CreateTokenPriceErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateTokenPriceError = CreateTokenPriceErrors[keyof CreateTokenPriceErrors];

export type CreateTokenPriceResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model: string;
        pricePerMillionInput: string;
        pricePerMillionOutput: string;
        createdAt: string;
        updatedAt: string;
    };
};

export type CreateTokenPriceResponse = CreateTokenPriceResponses[keyof CreateTokenPriceResponses];

export type DeleteTokenPriceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/token-prices/{id}';
};

export type DeleteTokenPriceErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteTokenPriceError = DeleteTokenPriceErrors[keyof DeleteTokenPriceErrors];

export type DeleteTokenPriceResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteTokenPriceResponse = DeleteTokenPriceResponses[keyof DeleteTokenPriceResponses];

export type GetTokenPriceData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/token-prices/{id}';
};

export type GetTokenPriceErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTokenPriceError = GetTokenPriceErrors[keyof GetTokenPriceErrors];

export type GetTokenPriceResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model: string;
        pricePerMillionInput: string;
        pricePerMillionOutput: string;
        createdAt: string;
        updatedAt: string;
    };
};

export type GetTokenPriceResponse = GetTokenPriceResponses[keyof GetTokenPriceResponses];

export type UpdateTokenPriceData = {
    body?: {
        provider?: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model?: string;
        pricePerMillionInput?: string;
        pricePerMillionOutput?: string;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/token-prices/{id}';
};

export type UpdateTokenPriceErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateTokenPriceError = UpdateTokenPriceErrors[keyof UpdateTokenPriceErrors];

export type UpdateTokenPriceResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        provider: 'openai' | 'gemini' | 'anthropic' | 'bedrock' | 'cohere' | 'cerebras' | 'mistral' | 'vllm' | 'ollama' | 'zhipuai';
        model: string;
        pricePerMillionInput: string;
        pricePerMillionOutput: string;
        createdAt: string;
        updatedAt: string;
    };
};

export type UpdateTokenPriceResponse = UpdateTokenPriceResponses[keyof UpdateTokenPriceResponses];

export type GetTokensData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter team tokens to only show tokens for teams the profile is assigned to
         */
        profileId?: string;
    };
    url: '/api/tokens';
};

export type GetTokensErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTokensError = GetTokensErrors[keyof GetTokensErrors];

export type GetTokensResponses = {
    /**
     * Default Response
     */
    200: {
        tokens: Array<{
            id: string;
            name: string;
            tokenStart: string;
            isOrganizationToken: boolean;
            team: {
                id: string;
                name: string;
            } | null;
            createdAt: string;
            lastUsedAt: string | null;
        }>;
        permissions: {
            canAccessOrgToken: boolean;
            canAccessTeamTokens: boolean;
        };
    };
};

export type GetTokensResponse = GetTokensResponses[keyof GetTokensResponses];

export type GetTokenValueData = {
    body?: never;
    path: {
        tokenId: string;
    };
    query?: never;
    url: '/api/tokens/{tokenId}/value';
};

export type GetTokenValueErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTokenValueError = GetTokenValueErrors[keyof GetTokenValueErrors];

export type GetTokenValueResponses = {
    /**
     * Default Response
     */
    200: {
        value: string;
    };
};

export type GetTokenValueResponse = GetTokenValueResponses[keyof GetTokenValueResponses];

export type RotateTokenData = {
    body?: never;
    path: {
        tokenId: string;
    };
    query?: never;
    url: '/api/tokens/{tokenId}/rotate';
};

export type RotateTokenErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RotateTokenError = RotateTokenErrors[keyof RotateTokenErrors];

export type RotateTokenResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        tokenStart: string;
        isOrganizationToken: boolean;
        team: {
            id: string;
            name: string;
        } | null;
        createdAt: string;
        lastUsedAt: string | null;
        value: string;
    };
};

export type RotateTokenResponse = RotateTokenResponses[keyof RotateTokenResponses];

export type GetToolsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/tools';
};

export type GetToolsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetToolsError = GetToolsErrors[keyof GetToolsErrors];

export type GetToolsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        catalogId: string | null;
        delegateToAgentId: string | null;
        name: string;
        /**
         *
         * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
         *
         * The parameters the functions accepts, described as a JSON Schema object. See the
         * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
         * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
         * documentation about the format.
         *
         * Omitting parameters defines a function with an empty parameter list.
         *
         */
        parameters?: {
            [key: string]: unknown;
        };
        description: string | null;
        policiesAutoConfiguredAt: string | null;
        policiesAutoConfiguringStartedAt: string | null;
        policiesAutoConfiguredReasoning: string | null;
        createdAt: string;
        updatedAt: string;
        agent: {
            id: string;
            name: string;
        } | null;
        mcpServer: {
            id: string;
            name: string;
        } | null;
    }>;
};

export type GetToolsResponse = GetToolsResponses[keyof GetToolsResponses];

export type GetToolsWithAssignmentsData = {
    body?: never;
    path?: never;
    query?: {
        search?: string;
        /**
         * Can be 'llm-proxy' or a catalogId
         */
        origin?: string;
        /**
         * Hide built-in Archestra tools
         */
        excludeArchestraTools?: boolean;
        sortBy?: 'name' | 'origin' | 'createdAt' | 'assignmentCount';
        sortDirection?: 'asc' | 'desc';
        limit?: number;
        offset?: number;
    };
    url: '/api/tools/with-assignments';
};

export type GetToolsWithAssignmentsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetToolsWithAssignmentsError = GetToolsWithAssignmentsErrors[keyof GetToolsWithAssignmentsErrors];

export type GetToolsWithAssignmentsResponses = {
    /**
     * Default Response
     */
    200: {
        data: Array<{
            id: string;
            name: string;
            description: string | null;
            /**
             *
             * https://github.com/openai/openai-node/blob/master/src/resources/shared.ts#L217
             *
             * The parameters the functions accepts, described as a JSON Schema object. See the
             * [guide](https://platform.openai.com/docs/guides/function-calling) for examples,
             * and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for
             * documentation about the format.
             *
             * Omitting parameters defines a function with an empty parameter list.
             *
             */
            parameters?: {
                [key: string]: unknown;
            };
            catalogId: string | null;
            mcpServerId: string | null;
            mcpServerName: string | null;
            mcpServerCatalogId: string | null;
            createdAt: string;
            updatedAt: string;
            assignmentCount: number;
            assignments: Array<{
                agentToolId: string;
                agent: {
                    id: string;
                    name: string;
                };
                credentialSourceMcpServerId: string | null;
                credentialOwnerEmail: string | null;
                executionSourceMcpServerId: string | null;
                executionOwnerEmail: string | null;
                useDynamicTeamCredential: boolean;
                responseModifierTemplate: string | null;
            }>;
        }>;
        pagination: {
            currentPage: number;
            limit: number;
            total: number;
            totalPages: number;
            hasNext: boolean;
            hasPrev: boolean;
        };
    };
};

export type GetToolsWithAssignmentsResponse = GetToolsWithAssignmentsResponses[keyof GetToolsWithAssignmentsResponses];

export type DeleteToolData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/tools/{id}';
};

export type DeleteToolErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteToolError = DeleteToolErrors[keyof DeleteToolErrors];

export type DeleteToolResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteToolResponse = DeleteToolResponses[keyof DeleteToolResponses];

export type GetUserPermissionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/user/permissions';
};

export type GetUserPermissionsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetUserPermissionsError = GetUserPermissionsErrors[keyof GetUserPermissionsErrors];

export type GetUserPermissionsResponses = {
    /**
     * Default Response
     */
    200: {
        [key: string]: Array<'create' | 'read' | 'update' | 'delete' | 'admin' | 'cancel'>;
    };
};

export type GetUserPermissionsResponse = GetUserPermissionsResponses[keyof GetUserPermissionsResponses];

export type GetUserTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/user-tokens/me';
};

export type GetUserTokenErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetUserTokenError = GetUserTokenErrors[keyof GetUserTokenErrors];

export type GetUserTokenResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        tokenStart: string;
        createdAt: string;
        lastUsedAt: string | null;
    };
};

export type GetUserTokenResponse = GetUserTokenResponses[keyof GetUserTokenResponses];

export type GetUserTokenValueData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/user-tokens/me/value';
};

export type GetUserTokenValueErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetUserTokenValueError = GetUserTokenValueErrors[keyof GetUserTokenValueErrors];

export type GetUserTokenValueResponses = {
    /**
     * Default Response
     */
    200: {
        value: string;
    };
};

export type GetUserTokenValueResponse = GetUserTokenValueResponses[keyof GetUserTokenValueResponses];

export type RotateUserTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/user-tokens/me/rotate';
};

export type RotateUserTokenErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type RotateUserTokenError = RotateUserTokenErrors[keyof RotateUserTokenErrors];

export type RotateUserTokenResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        name: string;
        tokenStart: string;
        createdAt: string;
        lastUsedAt: string | null;
        value: string;
    };
};

export type RotateUserTokenResponse = RotateUserTokenResponses[keyof RotateUserTokenResponses];

export type VllmChatCompletionsWithDefaultAgentData = {
    body?: VllmChatCompletionRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for vLLM (often not required)
         */
        authorization?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/vllm/chat/completions';
};

export type VllmChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type VllmChatCompletionsWithDefaultAgentError = VllmChatCompletionsWithDefaultAgentErrors[keyof VllmChatCompletionsWithDefaultAgentErrors];

export type VllmChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: VllmChatCompletionResponse;
};

export type VllmChatCompletionsWithDefaultAgentResponse = VllmChatCompletionsWithDefaultAgentResponses[keyof VllmChatCompletionsWithDefaultAgentResponses];

export type VllmChatCompletionsWithAgentData = {
    body?: VllmChatCompletionRequestInput;
    headers?: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for vLLM (often not required)
         */
        authorization?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/vllm/{agentId}/chat/completions';
};

export type VllmChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type VllmChatCompletionsWithAgentError = VllmChatCompletionsWithAgentErrors[keyof VllmChatCompletionsWithAgentErrors];

export type VllmChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: VllmChatCompletionResponse;
};

export type VllmChatCompletionsWithAgentResponse = VllmChatCompletionsWithAgentResponses[keyof VllmChatCompletionsWithAgentResponses];

export type ZhipuaiChatCompletionsWithDefaultAgentData = {
    body?: ZhipuaiChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for Zhipu AI
         */
        authorization: string;
        'accept-language'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/zhipuai/chat/completions';
};

export type ZhipuaiChatCompletionsWithDefaultAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ZhipuaiChatCompletionsWithDefaultAgentError = ZhipuaiChatCompletionsWithDefaultAgentErrors[keyof ZhipuaiChatCompletionsWithDefaultAgentErrors];

export type ZhipuaiChatCompletionsWithDefaultAgentResponses = {
    /**
     * Default Response
     */
    200: ZhipuaiChatCompletionResponse;
};

export type ZhipuaiChatCompletionsWithDefaultAgentResponse = ZhipuaiChatCompletionsWithDefaultAgentResponses[keyof ZhipuaiChatCompletionsWithDefaultAgentResponses];

export type ZhipuaiChatCompletionsWithAgentData = {
    body?: ZhipuaiChatCompletionRequestInput;
    headers: {
        /**
         * The user agent of the client
         */
        'user-agent'?: string;
        /**
         * Bearer token for Zhipu AI
         */
        authorization: string;
        'accept-language'?: string;
    };
    path: {
        agentId: string;
    };
    query?: never;
    url: '/v1/zhipuai/{agentId}/chat/completions';
};

export type ZhipuaiChatCompletionsWithAgentErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ZhipuaiChatCompletionsWithAgentError = ZhipuaiChatCompletionsWithAgentErrors[keyof ZhipuaiChatCompletionsWithAgentErrors];

export type ZhipuaiChatCompletionsWithAgentResponses = {
    /**
     * Default Response
     */
    200: ZhipuaiChatCompletionResponse;
};

export type ZhipuaiChatCompletionsWithAgentResponse = ZhipuaiChatCompletionsWithAgentResponses[keyof ZhipuaiChatCompletionsWithAgentResponses];

export type GetPublicIdentityProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/identity-providers/public';
};

export type GetPublicIdentityProvidersErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetPublicIdentityProvidersError = GetPublicIdentityProvidersErrors[keyof GetPublicIdentityProvidersErrors];

export type GetPublicIdentityProvidersResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        providerId: string;
    }>;
};

export type GetPublicIdentityProvidersResponse = GetPublicIdentityProvidersResponses[keyof GetPublicIdentityProvidersResponses];

export type GetIdentityProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/identity-providers';
};

export type GetIdentityProvidersErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetIdentityProvidersError = GetIdentityProvidersErrors[keyof GetIdentityProvidersErrors];

export type GetIdentityProvidersResponses = {
    /**
     * Default Response
     */
    200: Array<{
        id: string;
        issuer: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        userId: string | null;
        providerId: string;
        organizationId: string | null;
        domain: string;
        domainVerified: boolean | null;
    }>;
};

export type GetIdentityProvidersResponse = GetIdentityProvidersResponses[keyof GetIdentityProvidersResponses];

export type CreateIdentityProviderData = {
    body: {
        issuer: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        userId?: string | null;
        providerId: string;
        domain: string;
        domainVerified?: boolean | null;
    };
    path?: never;
    query?: never;
    url: '/api/identity-providers';
};

export type CreateIdentityProviderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CreateIdentityProviderError = CreateIdentityProviderErrors[keyof CreateIdentityProviderErrors];

export type CreateIdentityProviderResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        issuer: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        userId: string | null;
        providerId: string;
        organizationId: string | null;
        domain: string;
        domainVerified: boolean | null;
    };
};

export type CreateIdentityProviderResponse = CreateIdentityProviderResponses[keyof CreateIdentityProviderResponses];

export type GetIdentityProviderIdpLogoutUrlData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/identity-providers/idp-logout-url';
};

export type GetIdentityProviderIdpLogoutUrlErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetIdentityProviderIdpLogoutUrlError = GetIdentityProviderIdpLogoutUrlErrors[keyof GetIdentityProviderIdpLogoutUrlErrors];

export type GetIdentityProviderIdpLogoutUrlResponses = {
    /**
     * Default Response
     */
    200: {
        url: string | null;
    };
};

export type GetIdentityProviderIdpLogoutUrlResponse = GetIdentityProviderIdpLogoutUrlResponses[keyof GetIdentityProviderIdpLogoutUrlResponses];

export type DeleteIdentityProviderData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/identity-providers/{id}';
};

export type DeleteIdentityProviderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteIdentityProviderError = DeleteIdentityProviderErrors[keyof DeleteIdentityProviderErrors];

export type DeleteIdentityProviderResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteIdentityProviderResponse = DeleteIdentityProviderResponses[keyof DeleteIdentityProviderResponses];

export type GetIdentityProviderData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/identity-providers/{id}';
};

export type GetIdentityProviderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetIdentityProviderError = GetIdentityProviderErrors[keyof GetIdentityProviderErrors];

export type GetIdentityProviderResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        issuer: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        userId: string | null;
        providerId: string;
        organizationId: string | null;
        domain: string;
        domainVerified: boolean | null;
    };
};

export type GetIdentityProviderResponse = GetIdentityProviderResponses[keyof GetIdentityProviderResponses];

export type UpdateIdentityProviderData = {
    body?: {
        issuer?: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        providerId?: string;
        domain?: string;
        domainVerified?: boolean | null;
    };
    path: {
        id: string;
    };
    query?: never;
    url: '/api/identity-providers/{id}';
};

export type UpdateIdentityProviderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type UpdateIdentityProviderError = UpdateIdentityProviderErrors[keyof UpdateIdentityProviderErrors];

export type UpdateIdentityProviderResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        issuer: string;
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L22
         */
        oidcConfig?: {
            issuer: string;
            pkce: boolean;
            clientId: string;
            clientSecret: string;
            authorizationEndpoint?: string;
            discoveryEndpoint: string;
            userInfoEndpoint?: string;
            scopes?: Array<string>;
            overrideUserInfo?: boolean;
            tokenEndpoint?: string;
            tokenEndpointAuthentication?: 'client_secret_post' | 'client_secret_basic';
            jwksEndpoint?: string;
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L3
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                image?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        /**
         * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L40
         */
        samlConfig?: {
            issuer: string;
            entryPoint: string;
            cert: string;
            callbackUrl: string;
            audience?: string;
            idpMetadata?: {
                metadata?: string;
                entityID?: string;
                entityURL?: string;
                redirectURL?: string;
                cert?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
                singleSignOnService?: Array<{
                    Binding: string;
                    Location: string;
                }>;
            };
            spMetadata: {
                metadata?: string;
                entityID?: string;
                binding?: string;
                privateKey?: string;
                privateKeyPass?: string;
                isAssertionEncrypted?: boolean;
                encPrivateKey?: string;
                encPrivateKeyPass?: string;
            };
            wantAssertionsSigned?: boolean;
            signatureAlgorithm?: string;
            digestAlgorithm?: string;
            identifierFormat?: string;
            privateKey?: string;
            decryptionPvk?: string;
            additionalParams?: {
                [key: string]: unknown;
            };
            /**
             * https://github.com/better-auth/better-auth/blob/v1.4.0/packages/sso/src/types.ts#L12C30-L20C2
             */
            mapping?: {
                id?: string;
                email?: string;
                emailVerified?: string;
                name?: string;
                firstName?: string;
                lastName?: string;
                extraFields?: {
                    [key: string]: string;
                };
            };
        };
        roleMapping?: {
            rules?: Array<{
                expression: string;
                role: string;
            }>;
            defaultRole?: string;
            strictMode?: boolean;
            skipRoleSync?: boolean;
        };
        teamSyncConfig?: {
            groupsExpression?: string;
            enabled?: boolean;
        };
        userId: string | null;
        providerId: string;
        organizationId: string | null;
        domain: string;
        domainVerified: boolean | null;
    };
};

export type UpdateIdentityProviderResponse = UpdateIdentityProviderResponses[keyof UpdateIdentityProviderResponses];

export type DeleteTeamVaultFolderData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder';
};

export type DeleteTeamVaultFolderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type DeleteTeamVaultFolderError = DeleteTeamVaultFolderErrors[keyof DeleteTeamVaultFolderErrors];

export type DeleteTeamVaultFolderResponses = {
    /**
     * Default Response
     */
    200: {
        success: boolean;
    };
};

export type DeleteTeamVaultFolderResponse = DeleteTeamVaultFolderResponses[keyof DeleteTeamVaultFolderResponses];

export type GetTeamVaultFolderData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder';
};

export type GetTeamVaultFolderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamVaultFolderError = GetTeamVaultFolderErrors[keyof GetTeamVaultFolderErrors];

export type GetTeamVaultFolderResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        teamId: string;
        vaultPath: string;
        createdAt: string;
        updatedAt: string;
    } | null;
};

export type GetTeamVaultFolderResponse = GetTeamVaultFolderResponses[keyof GetTeamVaultFolderResponses];

export type SetTeamVaultFolderData = {
    body: {
        vaultPath: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder';
};

export type SetTeamVaultFolderErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type SetTeamVaultFolderError = SetTeamVaultFolderErrors[keyof SetTeamVaultFolderErrors];

export type SetTeamVaultFolderResponses = {
    /**
     * Default Response
     */
    200: {
        id: string;
        teamId: string;
        vaultPath: string;
        createdAt: string;
        updatedAt: string;
    };
};

export type SetTeamVaultFolderResponse = SetTeamVaultFolderResponses[keyof SetTeamVaultFolderResponses];

export type CheckTeamVaultFolderConnectivityData = {
    body?: {
        vaultPath?: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder/check-connectivity';
};

export type CheckTeamVaultFolderConnectivityErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type CheckTeamVaultFolderConnectivityError = CheckTeamVaultFolderConnectivityErrors[keyof CheckTeamVaultFolderConnectivityErrors];

export type CheckTeamVaultFolderConnectivityResponses = {
    /**
     * Default Response
     */
    200: {
        connected: boolean;
        secretCount: number;
        error?: string;
    };
};

export type CheckTeamVaultFolderConnectivityResponse = CheckTeamVaultFolderConnectivityResponses[keyof CheckTeamVaultFolderConnectivityResponses];

export type ListTeamVaultFolderSecretsData = {
    body?: never;
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder/secrets';
};

export type ListTeamVaultFolderSecretsErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type ListTeamVaultFolderSecretsError = ListTeamVaultFolderSecretsErrors[keyof ListTeamVaultFolderSecretsErrors];

export type ListTeamVaultFolderSecretsResponses = {
    /**
     * Default Response
     */
    200: Array<{
        name: string;
        path: string;
    }>;
};

export type ListTeamVaultFolderSecretsResponse = ListTeamVaultFolderSecretsResponses[keyof ListTeamVaultFolderSecretsResponses];

export type GetTeamVaultSecretKeysData = {
    body: {
        secretPath: string;
    };
    path: {
        teamId: string;
    };
    query?: never;
    url: '/api/teams/{teamId}/vault-folder/secrets/keys';
};

export type GetTeamVaultSecretKeysErrors = {
    /**
     * Default Response
     */
    400: {
        error: {
            message: string;
            type: 'api_validation_error';
        };
    };
    /**
     * Default Response
     */
    401: {
        error: {
            message: string;
            type: 'api_authentication_error';
        };
    };
    /**
     * Default Response
     */
    403: {
        error: {
            message: string;
            type: 'api_authorization_error';
        };
    };
    /**
     * Default Response
     */
    404: {
        error: {
            message: string;
            type: 'api_not_found_error';
        };
    };
    /**
     * Default Response
     */
    409: {
        error: {
            message: string;
            type: 'api_conflict_error';
        };
    };
    /**
     * Default Response
     */
    500: {
        error: {
            message: string;
            type: 'api_internal_server_error';
        };
    };
};

export type GetTeamVaultSecretKeysError = GetTeamVaultSecretKeysErrors[keyof GetTeamVaultSecretKeysErrors];

export type GetTeamVaultSecretKeysResponses = {
    /**
     * Default Response
     */
    200: {
        keys: Array<string>;
    };
};

export type GetTeamVaultSecretKeysResponse = GetTeamVaultSecretKeysResponses[keyof GetTeamVaultSecretKeysResponses];
