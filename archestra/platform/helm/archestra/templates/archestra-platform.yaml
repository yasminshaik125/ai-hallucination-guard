{{/*
Validation: Ensure postgresql.enabled=false when using external database
*/}}
{{- if and .Values.postgresql.external_database_url .Values.postgresql.enabled (ne (toString .Values.postgresql.external_database_url) "from_vault") }}
{{- fail "Configuration error: When postgresql.external_database_url is set, you must also set postgresql.enabled=false to prevent deploying an unused PostgreSQL instance." }}
{{- end }}
---
apiVersion: v1
kind: Service
metadata:
  name: {{ include "archestra-platform.fullname" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "archestra-platform.labels" . | nindent 4 }}
  {{- with .Values.archestra.service.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  type: {{ .Values.archestra.service.type | default "ClusterIP" }}
  ports:
    - port: 9000
      targetPort: backend
      protocol: TCP
      name: backend
      {{- if and (eq (.Values.archestra.service.type | default "ClusterIP") "NodePort") .Values.archestra.service.nodePorts.backend }}
      nodePort: {{ .Values.archestra.service.nodePorts.backend }}
      {{- end }}
    - port: 9050
      targetPort: metrics
      protocol: TCP
      name: metrics
      {{- if and (eq (.Values.archestra.service.type | default "ClusterIP") "NodePort") .Values.archestra.service.nodePorts.metrics }}
      nodePort: {{ .Values.archestra.service.nodePorts.metrics }}
      {{- end }}
    - port: 3000
      targetPort: frontend
      protocol: TCP
      name: frontend
      {{- if and (eq (.Values.archestra.service.type | default "ClusterIP") "NodePort") .Values.archestra.service.nodePorts.frontend }}
      nodePort: {{ .Values.archestra.service.nodePorts.frontend }}
      {{- end }}
  selector:
    {{- include "archestra-platform.selectorLabels" . | nindent 4 }}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "archestra-platform.fullname" . }}
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "archestra-platform.labels" . | nindent 4 }}
spec:
  {{- if not .Values.archestra.horizontalPodAutoscaler.enabled }}
  replicas: {{ .Values.archestra.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "archestra-platform.selectorLabels" . | nindent 6 }}
  {{- with .Values.archestra.deploymentStrategy }}
  strategy:
    {{- toYaml . | nindent 4 }}
  {{- end }}
  template:
    metadata:
      labels:
        {{- include "archestra-platform.labels" . | nindent 8 }}
      {{- with .Values.archestra.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
    spec:
      serviceAccountName: {{ include "archestra-platform.serviceAccountName" . }}
      # Init container to wait for PostgreSQL to be ready before starting the application
      # This prevents the application from crashing when PostgreSQL is still starting up
      # and the application tries to run database migrations (in which it assumes that the database is already ready)
      initContainers:
        {{- if .Values.archestra.initContainers.vaultSecrets.enabled }}
        # Vault secret injection init container
        #
        # This init container authenticates with Vault, fetches secrets, and writes them
        # as KEY=VALUE pairs to /vault/secrets/env. The main container sources this file
        # on startup to load secrets as environment variables (see command override below).
        - name: vault-secrets
          image: {{ include "archestra-platform.image" . }}
          workingDir: /app/backend
          env:
            {{- include "archestra-platform.env" . | nindent 12 }}
            - name: VAULT_INJECTOR_SECRETS
              value: {{ .Values.archestra.initContainers.vaultSecrets.secrets | toJson | quote }}
          command: ["node", "--enable-source-maps", "dist/standalone-scripts/vault-env-injector.ee.mjs"]
          volumeMounts:
            - name: vault-secrets
              mountPath: /vault/secrets
        {{- end }}
        - name: wait-for-postgres
          image: busybox:1.36
          env:
            {{- include "archestra-platform.env" . | nindent 12 }}
          {{- if .Values.archestra.initContainers.vaultSecrets.enabled }}
          volumeMounts:
            - name: vault-secrets
              mountPath: /vault/secrets
              readOnly: true
          {{- end }}
          command:
            - sh
            - -c
            - |
              {{- if .Values.archestra.initContainers.waitForPostgres.enabled }}
              # Source Vault secrets if available (may override ARCHESTRA_DATABASE_URL)
              if [ -f /vault/secrets/env ]; then
                set -a
                . /vault/secrets/env
                set +a
              fi

              # Parse host and port from ARCHESTRA_DATABASE_URL
              # Format: postgresql://user:pass@host[:port]/database
              DB_URL="${ARCHESTRA_DATABASE_URL##*@}"  # Remove prefix up to last @ (handles passwords with @)
              HOST_PORT="${DB_URL%%/*}"               # Remove /database suffix
              HOST="${HOST_PORT%%:*}"                 # Extract host
              # Extract port, defaulting to 5432 if not specified
              case "$HOST_PORT" in
                *:*) PORT="${HOST_PORT##*:}" ;;
                *)   PORT="5432" ;;
              esac

              echo "Waiting for PostgreSQL at ${HOST}:${PORT}..."
              until nc -z "${HOST}" "${PORT}"; do
                echo "PostgreSQL is unavailable - sleeping"
                sleep 1
              done
              echo "PostgreSQL is up - continuing"
              {{- else }}
              echo "Skipping PostgreSQL readiness check"
              {{- end }}
      containers:
        - name: {{ .Chart.Name }}
          image: {{ include "archestra-platform.image" . }}
          imagePullPolicy: {{ .Values.archestra.imagePullPolicy | default "IfNotPresent" }}
          {{- if .Values.archestra.initContainers.vaultSecrets.enabled }}
          command: ["/bin/sh", "-c"]
          args:
            - |
              if [ -f /vault/secrets/env ]; then
                set -a
                . /vault/secrets/env
                set +a
              fi
              exec {{ .Values.archestra.initContainers.vaultSecrets.entrypoint | default "/docker-entrypoint.sh" }}
          {{- end }}
          ports:
            - name: backend
              containerPort: 9000
              protocol: TCP
            - name: metrics
              containerPort: 9050
              protocol: TCP
            - name: frontend
              containerPort: 3000
              protocol: TCP
          env:
            {{- include "archestra-platform.env" . | nindent 12 }}
          {{- with .Values.archestra.envFrom }}
          envFrom:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          {{- with .Values.archestra.resources }}
          resources:
            {{- toYaml . | nindent 12 }}
          {{- end }}
          # Startup probe - gives the application time to start up
          # Checks every 10 seconds for up to 5 minutes (30 failures * 10s)
          startupProbe:
            httpGet:
              path: /health
              port: backend
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 30
          # Liveness probe - restarts the container if it becomes unresponsive
          livenessProbe:
            httpGet:
              path: /health
              port: backend
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          # Readiness probe - marks the container as ready to receive traffic
          # Uses /ready endpoint which checks database connectivity
          readinessProbe:
            httpGet:
              path: /ready
              port: backend
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          {{- if or (and .Values.archestra.orchestrator.kubernetes.kubeconfig.enabled .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName) .Values.archestra.initContainers.vaultSecrets.enabled }}
          volumeMounts:
            {{- if and .Values.archestra.orchestrator.kubernetes.kubeconfig.enabled .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName }}
            - name: kubeconfig
              mountPath: {{ .Values.archestra.orchestrator.kubernetes.kubeconfig.mountPath }}
              readOnly: true
            {{- end }}
            {{- if .Values.archestra.initContainers.vaultSecrets.enabled }}
            - name: vault-secrets
              mountPath: /vault/secrets
              readOnly: true
            {{- end }}
          {{- end }}
      {{- with .Values.archestra.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- if or (and .Values.archestra.orchestrator.kubernetes.kubeconfig.enabled .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName) .Values.archestra.initContainers.vaultSecrets.enabled }}
      volumes:
        {{- if and .Values.archestra.orchestrator.kubernetes.kubeconfig.enabled .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName }}
        - name: kubeconfig
          secret:
            secretName: {{ .Values.archestra.orchestrator.kubernetes.kubeconfig.secretName }}
        {{- end }}
        {{- if .Values.archestra.initContainers.vaultSecrets.enabled }}
        - name: vault-secrets
          emptyDir:
            medium: Memory
        {{- end }}
      {{- end }}
