# WireMock configuration
wiremock:
  enabled: true
  image:
    repository: wiremock/wiremock
    tag: "3.13.1"
    pullPolicy: IfNotPresent
  service:
    type: NodePort
    port: 8080
    # NodePort for kind/CI environments (optional)
    nodePort: 30080
  # WireMock command arguments
  args:
    - --global-response-templating
    - --disable-gzip
    - --verbose

# Keycloak configuration for SSO testing
keycloak:
  enabled: true
  image:
    registry: quay.io
    repository: keycloak/keycloak
    tag: "26.0"
    pullPolicy: IfNotPresent
  # Admin credentials for e2e testing
  auth:
    adminUser: admin
    adminPassword: admin
  # Service configuration
  service:
    type: NodePort
    port: 8080
    nodePort: 30081
  # Resource limits for CI environment
  resources:
    requests:
      cpu: 250m
      memory: 512Mi
    limits:
      cpu: 1000m
      memory: 1024Mi
  # Liveness probe
  livenessProbe:
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 5
  # Readiness probe
  readinessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
  # Groups for role mapping tests
  groups:
    - name: "archestra-admins"
    - name: "archestra-users"
  # Test users for SSO E2E tests
  # The first user (admin) should match the Archestra admin user created during onboarding
  # so that SSO login can link to an existing account
  testUsers:
    # Admin user - in archestra-admins group for role mapping tests
    - username: "admin"
      email: "admin@example.com"
      password: "password"
      firstName: "Admin"
      lastName: "User"
      groups:
        - "archestra-admins"
    # Member user - in archestra-users group, should get member role
    - username: "member"
      email: "member@example.com"
      password: "memberpass"
      firstName: "Member"
      lastName: "User"
      groups:
        - "archestra-users"
  # Realm configuration for e2e testing
  # Set import: true to auto-import the realm on startup
  realm:
    import: true

# MCP Server with JWKS authentication for JWT propagation testing
mcpServerJwks:
  enabled: true
  image:
    repository: europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-jwks-keycloak
    tag: "0.0.1"
    pullPolicy: IfNotPresent
  # JWT audience claim the server expects (must match Keycloak client's audience mapper)
  jwtAudience: "archestra-oidc"
  # Service configuration
  service:
    type: NodePort
    port: 3456
    nodePort: 30082
  # Resource limits
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi

# HashiCorp Vault configuration for BYOS (Bring Your Own Secrets) testing
vault:
  enabled: true
  image:
    repository: hashicorp/vault
    tag: "latest"
    pullPolicy: IfNotPresent
  # Dev mode root token (auto-unsealed, in-memory storage)
  devRootToken: "dev-root-token"
  # Service configuration
  service:
    type: NodePort
    port: 8200
    nodePort: 30200
  # Resource limits for CI environment
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 256Mi
  # Readiness probe
  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
  # Kubernetes auth configuration (auto-configures K8s auth on startup)
  k8sAuth:
    enabled: false
    # Service account for the vault pod itself
    serviceAccountName: default
    # Service account that will authenticate to Vault (e.g., archestra-platform)
    boundServiceAccountName: archestra-platform
    boundServiceAccountNamespace: archestra-dev
    ttl: "24h"
  # Secrets to write into Vault on startup (used in post-start hook)
  secrets:
    - path: kv/archestra/config
      data:
        dburl: "postgresql://archestra:vault_e2e_custom_pw@archestra-platform-postgresql:5432/archestra_dev"
        dummy_var: "hello-from-vault"

